<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ovito.data &mdash; OVITO Python Reference 3.10.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css" />

  
    <link rel="shortcut icon" href="../_static/ovito.ico"/>
    <link rel="canonical" href="https://docs.ovito.org/python/modules/ovito_data.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/design-tabs.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ovito.io" href="ovito_io.html" />
    <link rel="prev" title="ovito" href="ovito.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #b94429" >

          
          
          <a href="../index.html">
            
              <img src="../_static/ovito_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.10.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/overview.html">High-level API overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/file_io.html">File I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/pipelines.html">Data pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/data_model.html">Data model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/data_manipulation.html">Manipulating data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/custom_modifiers.html">User-defined modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/custom_file_readers.html">User-defined file readers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/custom_overlays.html">User-defined viewport layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/rendering.html">Rendering &amp; visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/advanced_topics.html">Advanced topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/examples.html">Code examples</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ovito.html"><code class="docutils literal notranslate"><span class="pre">ovito</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ovito.data</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.BondType"><code class="docutils literal notranslate"><span class="pre">BondType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.BondType.radius"><code class="docutils literal notranslate"><span class="pre">BondType.radius</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.Bonds"><code class="docutils literal notranslate"><span class="pre">Bonds</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Bonds.add_bond"><code class="docutils literal notranslate"><span class="pre">Bonds.add_bond()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Bonds.bond_types"><code class="docutils literal notranslate"><span class="pre">Bonds.bond_types</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Bonds.colors"><code class="docutils literal notranslate"><span class="pre">Bonds.colors</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Bonds.pbc_vectors"><code class="docutils literal notranslate"><span class="pre">Bonds.pbc_vectors</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Bonds.selection"><code class="docutils literal notranslate"><span class="pre">Bonds.selection</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Bonds.topology"><code class="docutils literal notranslate"><span class="pre">Bonds.topology</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.BondsEnumerator"><code class="docutils literal notranslate"><span class="pre">BondsEnumerator</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.BondsEnumerator.bonds_of_particle"><code class="docutils literal notranslate"><span class="pre">BondsEnumerator.bonds_of_particle()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.CutoffNeighborFinder"><code class="docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find"><code class="docutils literal notranslate"><span class="pre">CutoffNeighborFinder.find()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find_all"><code class="docutils literal notranslate"><span class="pre">CutoffNeighborFinder.find_all()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find_at"><code class="docutils literal notranslate"><span class="pre">CutoffNeighborFinder.find_at()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.CutoffNeighborFinder.neighbor_distances"><code class="docutils literal notranslate"><span class="pre">CutoffNeighborFinder.neighbor_distances()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.CutoffNeighborFinder.neighbor_vectors"><code class="docutils literal notranslate"><span class="pre">CutoffNeighborFinder.neighbor_vectors()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.DataCollection"><code class="docutils literal notranslate"><span class="pre">DataCollection</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.apply"><code class="docutils literal notranslate"><span class="pre">DataCollection.apply()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.attributes"><code class="docutils literal notranslate"><span class="pre">DataCollection.attributes</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.cell"><code class="docutils literal notranslate"><span class="pre">DataCollection.cell</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.clone"><code class="docutils literal notranslate"><span class="pre">DataCollection.clone()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.create_cell"><code class="docutils literal notranslate"><span class="pre">DataCollection.create_cell()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.create_particles"><code class="docutils literal notranslate"><span class="pre">DataCollection.create_particles()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.dislocations"><code class="docutils literal notranslate"><span class="pre">DataCollection.dislocations</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.grids"><code class="docutils literal notranslate"><span class="pre">DataCollection.grids</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.lines"><code class="docutils literal notranslate"><span class="pre">DataCollection.lines</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.objects"><code class="docutils literal notranslate"><span class="pre">DataCollection.objects</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.particles"><code class="docutils literal notranslate"><span class="pre">DataCollection.particles</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.surfaces"><code class="docutils literal notranslate"><span class="pre">DataCollection.surfaces</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.tables"><code class="docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataCollection.triangle_meshes"><code class="docutils literal notranslate"><span class="pre">DataCollection.triangle_meshes</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.DataObject"><code class="docutils literal notranslate"><span class="pre">DataObject</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataObject.identifier"><code class="docutils literal notranslate"><span class="pre">DataObject.identifier</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataObject.make_mutable"><code class="docutils literal notranslate"><span class="pre">DataObject.make_mutable()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataObject.vis"><code class="docutils literal notranslate"><span class="pre">DataObject.vis</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.DataTable"><code class="docutils literal notranslate"><span class="pre">DataTable</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataTable.axis_label_x"><code class="docutils literal notranslate"><span class="pre">DataTable.axis_label_x</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataTable.interval"><code class="docutils literal notranslate"><span class="pre">DataTable.interval</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataTable.plot_mode"><code class="docutils literal notranslate"><span class="pre">DataTable.plot_mode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataTable.x"><code class="docutils literal notranslate"><span class="pre">DataTable.x</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataTable.xy"><code class="docutils literal notranslate"><span class="pre">DataTable.xy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DataTable.y"><code class="docutils literal notranslate"><span class="pre">DataTable.y</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.DislocationNetwork"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.arm_count"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector.arm_count</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.arms"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector.arms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.is_head"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector.is_head</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.is_tail"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector.is_tail</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.line"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector.line</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.next_arm"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector.next_arm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.position"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Connector.position</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.cluster_id"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.cluster_id</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.connectors"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.connectors</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.custom_color"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.custom_color</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.id"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.id</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.is_infinite_line"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.is_infinite_line</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.is_loop"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.is_loop</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.length"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.length</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.point_along_line"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.point_along_line()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.points"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.points</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.spatial_burgers_vector"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.spatial_burgers_vector</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ovito.data.DislocationNetwork.Line.true_burgers_vector"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.Line.true_burgers_vector</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DislocationNetwork.find_nodes"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.find_nodes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DislocationNetwork.lines"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.lines</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.DislocationNetwork.set_line"><code class="docutils literal notranslate"><span class="pre">DislocationNetwork.set_line()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.ElementType"><code class="docutils literal notranslate"><span class="pre">ElementType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ElementType.color"><code class="docutils literal notranslate"><span class="pre">ElementType.color</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ElementType.enabled"><code class="docutils literal notranslate"><span class="pre">ElementType.enabled</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ElementType.id"><code class="docutils literal notranslate"><span class="pre">ElementType.id</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ElementType.name"><code class="docutils literal notranslate"><span class="pre">ElementType.name</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.Lines"><code class="docutils literal notranslate"><span class="pre">Lines</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Lines.create_line"><code class="docutils literal notranslate"><span class="pre">Lines.create_line()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Lines.positions"><code class="docutils literal notranslate"><span class="pre">Lines.positions</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Lines.sections"><code class="docutils literal notranslate"><span class="pre">Lines.sections</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Lines.time_stamps"><code class="docutils literal notranslate"><span class="pre">Lines.time_stamps</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.NearestNeighborFinder"><code class="docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.NearestNeighborFinder.find"><code class="docutils literal notranslate"><span class="pre">NearestNeighborFinder.find()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.NearestNeighborFinder.find_all"><code class="docutils literal notranslate"><span class="pre">NearestNeighborFinder.find_all()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.NearestNeighborFinder.find_at"><code class="docutils literal notranslate"><span class="pre">NearestNeighborFinder.find_at()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.ParticleType"><code class="docutils literal notranslate"><span class="pre">ParticleType</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.backface_culling"><code class="docutils literal notranslate"><span class="pre">ParticleType.backface_culling</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.highlight_edges"><code class="docutils literal notranslate"><span class="pre">ParticleType.highlight_edges</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.load_defaults"><code class="docutils literal notranslate"><span class="pre">ParticleType.load_defaults()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.load_shape"><code class="docutils literal notranslate"><span class="pre">ParticleType.load_shape()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.mass"><code class="docutils literal notranslate"><span class="pre">ParticleType.mass</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.mesh"><code class="docutils literal notranslate"><span class="pre">ParticleType.mesh</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.radius"><code class="docutils literal notranslate"><span class="pre">ParticleType.radius</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.shape"><code class="docutils literal notranslate"><span class="pre">ParticleType.shape</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.use_mesh_color"><code class="docutils literal notranslate"><span class="pre">ParticleType.use_mesh_color</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.ParticleType.vdw_radius"><code class="docutils literal notranslate"><span class="pre">ParticleType.vdw_radius</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.Particles"><code class="docutils literal notranslate"><span class="pre">Particles</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.add_particle"><code class="docutils literal notranslate"><span class="pre">Particles.add_particle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.angles"><code class="docutils literal notranslate"><span class="pre">Particles.angles</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.bonds"><code class="docutils literal notranslate"><span class="pre">Particles.bonds</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.colors"><code class="docutils literal notranslate"><span class="pre">Particles.colors</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.create_bonds"><code class="docutils literal notranslate"><span class="pre">Particles.create_bonds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.delta_vector"><code class="docutils literal notranslate"><span class="pre">Particles.delta_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.dihedrals"><code class="docutils literal notranslate"><span class="pre">Particles.dihedrals</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.forces"><code class="docutils literal notranslate"><span class="pre">Particles.forces</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.identifiers"><code class="docutils literal notranslate"><span class="pre">Particles.identifiers</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.impropers"><code class="docutils literal notranslate"><span class="pre">Particles.impropers</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.masses"><code class="docutils literal notranslate"><span class="pre">Particles.masses</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.orientations"><code class="docutils literal notranslate"><span class="pre">Particles.orientations</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.particle_types"><code class="docutils literal notranslate"><span class="pre">Particles.particle_types</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.positions"><code class="docutils literal notranslate"><span class="pre">Particles.positions</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.remap_indices"><code class="docutils literal notranslate"><span class="pre">Particles.remap_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.selection"><code class="docutils literal notranslate"><span class="pre">Particles.selection</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.structure_types"><code class="docutils literal notranslate"><span class="pre">Particles.structure_types</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Particles.velocities"><code class="docutils literal notranslate"><span class="pre">Particles.velocities</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.Property"><code class="docutils literal notranslate"><span class="pre">Property</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.add_type_id"><code class="docutils literal notranslate"><span class="pre">Property.add_type_id()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.add_type_name"><code class="docutils literal notranslate"><span class="pre">Property.add_type_name()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.component_count"><code class="docutils literal notranslate"><span class="pre">Property.component_count</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.component_names"><code class="docutils literal notranslate"><span class="pre">Property.component_names</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.name"><code class="docutils literal notranslate"><span class="pre">Property.name</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.type_by_id"><code class="docutils literal notranslate"><span class="pre">Property.type_by_id()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.type_by_name"><code class="docutils literal notranslate"><span class="pre">Property.type_by_name()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.Property.types"><code class="docutils literal notranslate"><span class="pre">Property.types</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.PropertyContainer"><code class="docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.PropertyContainer.count"><code class="docutils literal notranslate"><span class="pre">PropertyContainer.count</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.PropertyContainer.create_property"><code class="docutils literal notranslate"><span class="pre">PropertyContainer.create_property()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.PropertyContainer.delete_elements"><code class="docutils literal notranslate"><span class="pre">PropertyContainer.delete_elements()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.PropertyContainer.delete_indices"><code class="docutils literal notranslate"><span class="pre">PropertyContainer.delete_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.PropertyContainer.title"><code class="docutils literal notranslate"><span class="pre">PropertyContainer.title</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.SimulationCell"><code class="docutils literal notranslate"><span class="pre">SimulationCell</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SimulationCell.delta_vector"><code class="docutils literal notranslate"><span class="pre">SimulationCell.delta_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SimulationCell.inverse"><code class="docutils literal notranslate"><span class="pre">SimulationCell.inverse</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SimulationCell.is2D"><code class="docutils literal notranslate"><span class="pre">SimulationCell.is2D</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SimulationCell.pbc"><code class="docutils literal notranslate"><span class="pre">SimulationCell.pbc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SimulationCell.volume"><code class="docutils literal notranslate"><span class="pre">SimulationCell.volume</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SimulationCell.volume2D"><code class="docutils literal notranslate"><span class="pre">SimulationCell.volume2D</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.SurfaceMesh"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.connect_opposite_halfedges"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.connect_opposite_halfedges()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.create_face"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.create_face()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.create_faces"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.create_faces()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.create_vertices"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.create_vertices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.domain"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.domain</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.faces"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.faces</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.get_clipping_planes"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.get_clipping_planes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.get_face_vertices"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.get_face_vertices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.locate_point"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.locate_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.regions"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.regions</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.set_clipping_planes"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.set_clipping_planes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.space_filling_region"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.space_filling_region</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.to_triangle_mesh"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.to_triangle_mesh()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.topology"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.topology</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMesh.vertices"><code class="docutils literal notranslate"><span class="pre">SurfaceMesh.vertices</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.adjacent_face"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.adjacent_face()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.count_face_edges"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.count_face_edges()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.count_manifolds"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.count_manifolds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.count_vertex_edges"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.count_vertex_edges()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.edge_count"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.edge_count</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.face_count"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.face_count</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.find_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.find_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_edge_vertex"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.first_edge_vertex()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_face_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.first_face_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_face_vertex"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.first_face_vertex()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_vertex_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.first_vertex_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.has_opposite_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.has_opposite_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.has_opposite_face"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.has_opposite_face()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.is_closed"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.is_closed</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_face_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.next_face_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_manifold_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.next_manifold_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_vertex_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.next_vertex_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.opposite_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.opposite_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.opposite_face"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.opposite_face()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.prev_face_edge"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.prev_face_edge()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.second_edge_vertex"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.second_edge_vertex()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.vertex_count"><code class="docutils literal notranslate"><span class="pre">SurfaceMeshTopology.vertex_count</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.TriangleMesh"><code class="docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.TriangleMesh.face_count"><code class="docutils literal notranslate"><span class="pre">TriangleMesh.face_count</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.TriangleMesh.get_faces"><code class="docutils literal notranslate"><span class="pre">TriangleMesh.get_faces()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.TriangleMesh.get_vertices"><code class="docutils literal notranslate"><span class="pre">TriangleMesh.get_vertices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.TriangleMesh.set_faces"><code class="docutils literal notranslate"><span class="pre">TriangleMesh.set_faces()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.TriangleMesh.set_vertices"><code class="docutils literal notranslate"><span class="pre">TriangleMesh.set_vertices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.TriangleMesh.vertex_count"><code class="docutils literal notranslate"><span class="pre">TriangleMesh.vertex_count</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ovito.data.VoxelGrid"><code class="docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.VoxelGrid.domain"><code class="docutils literal notranslate"><span class="pre">VoxelGrid.domain</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.VoxelGrid.grid_type"><code class="docutils literal notranslate"><span class="pre">VoxelGrid.grid_type</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.VoxelGrid.shape"><code class="docutils literal notranslate"><span class="pre">VoxelGrid.shape</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#ovito.data.VoxelGrid.view"><code class="docutils literal notranslate"><span class="pre">VoxelGrid.view()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ovito_io.html"><code class="docutils literal notranslate"><span class="pre">ovito.io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_io_ase.html"><code class="docutils literal notranslate"><span class="pre">ovito.io.ase</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_io_lammps.html"><code class="docutils literal notranslate"><span class="pre">ovito.io.lammps</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_modifiers.html"><code class="docutils literal notranslate"><span class="pre">ovito.modifiers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_pipeline.html"><code class="docutils literal notranslate"><span class="pre">ovito.pipeline</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_traits.html"><code class="docutils literal notranslate"><span class="pre">ovito.traits</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ovito_vis.html"><code class="docutils literal notranslate"><span class="pre">ovito.vis</span></code></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #b94429" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OVITO Python Reference</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          

<div role="navigation" aria-label="Breadcrumbs">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="docutils literal notranslate"><span class="pre">ovito.data</span></code></li>
      <li class="wy-breadcrumbs-aside" style="text-align: right;">
          <a href="https://www.ovito.org" style="padding: 1px;"">www.ovito.org&nbsp;<span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a><br>
          <a href="../../index.html" style="padding: 1px;">User&nbsp;Manual&nbsp;<span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-ovito.data">
<span id="ovito-data"></span><h1><code class="docutils literal notranslate"><span class="pre">ovito.data</span></code><a class="headerlink" href="#module-ovito.data" title="Permalink to this heading"></a></h1>
<p>This Python module defines various data object types, which are produced and processed within OVITO’s data pipeline system.
It also provides the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> class as a container for such data objects as well as several utility classes for
computing neighbor lists and iterating over the bonds of connected to a particle.</p>
<p><strong>Data containers:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a> - base of all data object types in OVITO</p></li>
<li><p><a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> - a general container for data objects representing an entire dataset</p></li>
<li><p><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> - manages a set of uniform <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> arrays</p></li>
<li><p><a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> - a specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for particles</p></li>
<li><p><a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> - specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for bonds</p></li>
<li><p><a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> - specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for 2d and 3d volumetric grids</p></li>
<li><p><a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> - specialized <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> for tabulated data</p></li>
<li><p><a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> - set of 3d line segments</p></li>
</ul>
</div></blockquote>
<p><strong>Data objects:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> - uniform array of property values</p></li>
<li><p><a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> - simulation box geometry and boundary conditions</p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> - polyhedral mesh representing the boundaries of spatial regions</p></li>
<li><p><a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> - general mesh structure made of vertices and triangular faces</p></li>
<li><p><a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a> - set of discrete dislocation lines with Burgers vector information</p></li>
</ul>
</div></blockquote>
<p><strong>Auxiliary data objects:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> - base class for type descriptors used in <em>typed properties</em></p></li>
<li><p><a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> - describes a single particle or atom type</p></li>
<li><p><a class="reference internal" href="#ovito.data.BondType" title="ovito.data.BondType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondType</span></code></a> - describes a single bond type</p></li>
</ul>
</div></blockquote>
<p><strong>Utility classes:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.CutoffNeighborFinder" title="ovito.data.CutoffNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code></a> - finds neighboring particles within a cutoff distance</p></li>
<li><p><a class="reference internal" href="#ovito.data.NearestNeighborFinder" title="ovito.data.NearestNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code></a> - finds <em>N</em> nearest neighbor particles</p></li>
<li><p><a class="reference internal" href="#ovito.data.BondsEnumerator" title="ovito.data.BondsEnumerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code></a> - lets you efficiently iterate over the bonds connected to a particle</p></li>
</ul>
</div></blockquote>
<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.BondType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">BondType</span></span><a class="headerlink" href="#ovito.data.BondType" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.ElementType</span></code></a></p>
<p>Represents a bond type. This class inherits all its fields from the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> base class.</p>
<p>You can enumerate the list of defined bond types by accessing the <a class="reference internal" href="#ovito.data.Bonds.bond_types" title="ovito.data.Bonds.bond_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_types</span></code></a> bond property object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bond_type_property</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">bond_types</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">bond_type_property</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.BondType.radius">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">radius</span></span><a class="headerlink" href="#ovito.data.BondType.radius" title="Permalink to this definition"></a></dt>
<dd><p>This attribute controls the display radius of all bonds of this type.</p>
<p>When set to zero, bonds of this type will be rendered using the standard width specified by the <a class="reference internal" href="ovito_vis.html#ovito.vis.BondsVis.width" title="ovito.vis.BondsVis.width"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BondsVis.radius</span></code></a> parameter. Furthermore, precedence is given to any per-bond widths assigned to the <code class="docutils literal notranslate"><span class="pre">Width</span></code> <a class="reference internal" href="#bond-types-list"><span class="std std-ref">bond property</span></a> if that property exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0.0</span></code></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.10.0.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.Bonds">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">Bonds</span></span><a class="headerlink" href="#ovito.data.Bonds" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
<p>Stores the list of bonds and their properties. A <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> object is always part of a parent <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object.
You can access it as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of bonds:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> class inherits the <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> attribute from its <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class. This attribute returns the number of bonds.</p>
<p><strong>Bond properties</strong></p>
<p>Bonds can be associated with arbitrary <em>bond properties</em>, which are managed in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> container
as a set of <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data arrays. Each bond property has a unique name by which it can be looked up:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bond property names:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="k">if</span> <span class="s1">&#39;Length&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
    <span class="n">length_prop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="s1">&#39;Length&#39;</span><span class="p">]</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">length_prop</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>New bond properties can be added using the <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropertyContainer.create_property()</span></code></a> method.</p>
<p><strong>Bond topology</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Topology</span></code> bond property, which is always present,
defines the connectivity between particles in the form of a <em>N</em> x 2 array of indices into the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> array.
In other words, each bond is defined by a pair of particle indices.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">topology</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bond from particle </span><span class="si">%i</span><span class="s2"> to particle </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the bonds of a system are not stored in any particular order.
If you need to enumerate all bonds connected to a certain particle, you can use the <a class="reference internal" href="#ovito.data.BondsEnumerator" title="ovito.data.BondsEnumerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code></a> utility class for that.</p>
<p><strong>Bonds visualization</strong></p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code> data object has a <a class="reference internal" href="ovito_vis.html#ovito.vis.BondsVis" title="ovito.vis.BondsVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsVis</span></code></a> element attached to it,
which controls the visual appearance of the bonds in rendered images. It can be accessed through the <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a>
attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">flat_shading</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="mf">0.3</span>
</pre></div>
</div>
<p><strong>Computing bond vectors</strong></p>
<p>Since each bond is defined by two indices into the particles array, we can use these indices to determine the corresponding spatial
bond <em>vectors</em> connecting the particles. They can be computed from the positions of the particles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topology</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">topology</span>
<span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span>
<span class="n">bond_vectors</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">topology</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">topology</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
<p>Here, the first and the second column of the bonds topology array are used to index into the particle positions array.
The subtraction of the two indexed arrays yields the list of bond vectors. Each vector in this list points
from the first particle to the second particle of the corresponding bond.</p>
<p>Finally, we may have to correct for the effect of periodic boundary conditions when a bond
connects two particles on opposite sides of the box. OVITO keeps track of such cases by means of the
the special <code class="docutils literal notranslate"><span class="pre">Periodic</span> <span class="pre">Image</span></code> bond property. It stores a shift vector for each bond, specifying the directions in which the bond
crosses periodic boundaries. We make use of this information to correct the bond vectors computed above.
This is done by adding the product of the cell matrix and the shift vectors from the <code class="docutils literal notranslate"><span class="pre">Periodic</span> <span class="pre">Image</span></code> bond property:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bond_vectors</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">pbc_vectors</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>The shift vectors array is transposed here to facilitate the transformation
of the entire array of vectors with a single 3x3 cell matrix.
To summarize: In the two code snippets above, we have performed
the following calculation of the <em>unwrapped</em> vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> for every bond (<em>a</em>, <em>b</em>) in parallel:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(\mathbf{v} = \mathbf{x}_b - \mathbf{x}_a + \mathbf{H} \cdot (n_x, n_y, n_z)^{T}\)</span>,</p>
</div></blockquote>
<p>with <span class="math notranslate nohighlight">\(\mathbf{H}\)</span> denoting the simulation cell matrix and <span class="math notranslate nohighlight">\((n_x, n_y, n_z)\)</span> the bond’s PBC shift vector.</p>
<p id="bond-types-list"><strong>Standard bond properties</strong></p>
<p>The following standard properties are defined for bonds:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property name</p></th>
<th class="head"><p>Python access</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Bond Type</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.bond_types" title="ovito.data.Bonds.bond_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_types</span></code></a></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Color</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.colors" title="ovito.data.Bonds.colors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">colors</span></code></a></p></td>
<td><p>float32</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Length</span></p></td>
<td></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Particle Identifiers</span></p></td>
<td></td>
<td><p>int64</p></td>
<td><p>A, B</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Periodic Image</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.pbc_vectors" title="ovito.data.Bonds.pbc_vectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc_vectors</span></code></a></p></td>
<td><p>int32</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Selection</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.selection" title="ovito.data.Bonds.selection"><code class="xref py py-attr docutils literal notranslate"><span class="pre">selection</span></code></a></p></td>
<td><p>int8</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Topology</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Bonds.topology" title="ovito.data.Bonds.topology"><code class="xref py py-attr docutils literal notranslate"><span class="pre">topology</span></code></a></p></td>
<td><p>int64</p></td>
<td><p>1, 2</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Transparency</span></p></td>
<td></td>
<td><p>float32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Width</span></p></td>
<td></td>
<td><p>float32</p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Bonds.add_bond">
<span class="sig-name descname"><span class="pre">add_bond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbcvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Bonds.add_bond" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new bond between two particles <em>a</em> and <em>b</em>, both parameters being indices into the particles list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – Index of first particle connected by the new bond. Particle indices start at 0.</p></li>
<li><p><strong>b</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – Index of second particle connected by the new bond.</p></li>
<li><p><strong>type</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – Optional type ID to be assigned to the new bond. This value will be stored to the <a class="reference internal" href="#ovito.data.Bonds.bond_types" title="ovito.data.Bonds.bond_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bond_types</span></code></a> array.</p></li>
<li><p><strong>pbcvec</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a>) – Three integers specifying the bond’s crossings of periodic cell boundaries. The information will be stored in the <a class="reference internal" href="#ovito.data.Bonds.pbc_vectors" title="ovito.data.Bonds.pbc_vectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc_vectors</span></code></a> array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The index of the newly created bond, i.e. <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">(Bonds.count-1)</span></code></a>.</p>
</dd>
</dl>
<p>The method does <em>not</em> check if there already is an existing bond connecting the same pair of particles.</p>
<p>The method does <em>not</em> check if the particle indices <em>a</em> and <em>b</em> do exist. Thus, it is your responsibility to ensure that both indices
are in the range 0 to <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">(Particles.count-1)</span></code></a>.</p>
<p>In case the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> has periodic boundary conditions enabled, and the two particles connected by the bond are located in different periodic images,
make sure you provide the <em>pbcvec</em> argument. It is required so that OVITO does not draw the bond as a direct line from particle <em>a</em> to particle <em>b</em> but as a line passing through
the periodic cell faces. You can use the <a class="reference internal" href="#ovito.data.Particles.delta_vector" title="ovito.data.Particles.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Particles.delta_vector()</span></code></a> function to compute
<em>pbcvec</em> or use the <code class="docutils literal notranslate"><span class="pre">pbc_shift</span></code> vector returned by the <a class="reference internal" href="#ovito.data.CutoffNeighborFinder" title="ovito.data.CutoffNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code></a> utility.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Bonds.bond_types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bond_types</span></span><a class="headerlink" href="#ovito.data.Bonds.bond_types" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Bond</span> <span class="pre">Type</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Bonds.colors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">colors</span></span><a class="headerlink" href="#ovito.data.Bonds.colors" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Color</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Bonds.pbc_vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pbc_vectors</span></span><a class="headerlink" href="#ovito.data.Bonds.pbc_vectors" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Periodic</span> <span class="pre">Image</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Bonds.selection">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">selection</span></span><a class="headerlink" href="#ovito.data.Bonds.selection" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Selection</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Bonds.topology">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">topology</span></span><a class="headerlink" href="#ovito.data.Bonds.topology" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Topology</span></code> standard bond property; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.BondsEnumerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">BondsEnumerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bonds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><span class="pre">ovito.data.Bonds</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.BondsEnumerator" title="Permalink to this definition"></a></dt>
<dd><p>Utility class that permits efficient iteration over the bonds connected to specific particles.</p>
<p>The constructor takes a <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object as input. 
From the generally unordered list of bonds, the <code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code> will build a lookup table for quick enumeration  
of bonds of particular particles.</p>
<p>All bonds connected to a specific particle can be subsequently visited using the <a class="reference internal" href="#ovito.data.BondsEnumerator.bonds_of_particle" title="ovito.data.BondsEnumerator.bonds_of_particle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bonds_of_particle()</span></code></a> method.</p>
<p>Warning: Do not modify the underlying <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object while the <code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code> is in use. 
Adding or deleting bonds would render the internal lookup table of the <code class="xref py py-class docutils literal notranslate"><span class="pre">BondsEnumerator</span></code> invalid.</p>
<p><strong>Usage example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="kn">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="kn">import</span> <span class="n">BondsEnumerator</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="kn">import</span> <span class="n">ComputePropertyModifier</span>

<span class="c1"># Load a dataset containing atoms and bonds.</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s1">&#39;input/bonds.data.gz&#39;</span><span class="p">,</span> <span class="n">atom_style</span><span class="o">=</span><span class="s1">&#39;bond&#39;</span><span class="p">)</span>

<span class="c1"># For demonstration purposes, let&#39;s define a compute modifier that calculates the length </span>
<span class="c1"># of each bond, storing the results in a new bond property named &#39;Length&#39;.</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ComputePropertyModifier</span><span class="p">(</span><span class="n">operate_on</span><span class="o">=</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span> <span class="n">output_property</span><span class="o">=</span><span class="s1">&#39;Length&#39;</span><span class="p">,</span> <span class="n">expressions</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BondLength&#39;</span><span class="p">]))</span>

<span class="c1"># Obtain pipeline results.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span>  <span class="c1"># array with atomic positions</span>
<span class="n">bond_topology</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">topology</span>  <span class="c1"># array with bond topology</span>
<span class="n">bond_lengths</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="s1">&#39;Length&#39;</span><span class="p">]</span>     <span class="c1"># array with bond lengths</span>

<span class="c1"># Create bonds enumerator object.</span>
<span class="n">bonds_enum</span> <span class="o">=</span> <span class="n">BondsEnumerator</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>

<span class="c1"># Loop over atoms.</span>
<span class="k">for</span> <span class="n">particle_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
    <span class="c1"># Loop over bonds of current atom.</span>
    <span class="k">for</span> <span class="n">bond_index</span> <span class="ow">in</span> <span class="n">bonds_enum</span><span class="o">.</span><span class="n">bonds_of_particle</span><span class="p">(</span><span class="n">particle_index</span><span class="p">):</span>
        <span class="c1"># Obtain the indices of the two particles connected by the bond:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">bond_topology</span><span class="p">[</span><span class="n">bond_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">bond_topology</span><span class="p">[</span><span class="n">bond_index</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Bond directions can be arbitrary (a-&gt;b or b-&gt;a):</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">particle_index</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="n">particle_index</span><span class="p">)</span>
        
        <span class="c1"># Obtain the length of the bond from the &#39;Length&#39; bond property:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">bond_lengths</span><span class="p">[</span><span class="n">bond_index</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bond from atom </span><span class="si">%i</span><span class="s2"> to atom </span><span class="si">%i</span><span class="s2"> has length </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.BondsEnumerator.bonds_of_particle">
<span class="sig-name descname"><span class="pre">bonds_of_particle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Iterator</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#ovito.data.BondsEnumerator.bonds_of_particle" title="Permalink to this definition"></a></dt>
<dd><p>Returns an iterator yielding the indices of the bonds connected to the given particle. The indices can be used to index into the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> arrays of the <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.CutoffNeighborFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">CutoffNeighborFinder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_collection</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder" title="Permalink to this definition"></a></dt>
<dd><p>A utility class that computes particle neighbor lists.</p>
<p>This class lets you iterate over all neighbors of a particle that are located within a specified spherical cutoff.
You can use it to build neighbor lists or perform computations that require neighbor vector information.</p>
<p>The constructor takes a positive cutoff radius and a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>
providing the input particles and the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> (needed for periodic systems).</p>
<p>Once the <code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code> has been constructed, you can call its <a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find" title="ovito.data.CutoffNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method to
iterate over the neighbors of a particle, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="kn">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="kn">import</span> <span class="n">CutoffNeighborFinder</span>

<span class="c1"># Load input simulation file.</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="c1"># Initialize neighbor finder object:</span>
<span class="n">cutoff</span> <span class="o">=</span> <span class="mf">3.5</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">CutoffNeighborFinder</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># Prefetch the property array containing the particle type information:</span>
<span class="n">ptypes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span>

<span class="c1"># Loop over all particles:</span>
<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Neighbors of particle </span><span class="si">%i</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>

    <span class="c1"># Iterate over the neighbors of the current particle:</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">pbc_shift</span><span class="p">)</span>

        <span class="c1"># The index can be used to access properties of the current neighbor, e.g.</span>
        <span class="n">type_of_neighbor</span> <span class="o">=</span> <span class="n">ptypes</span><span class="p">[</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>Note: In case you rather want to determine the <em>N</em> nearest neighbors of a particle,
use the <a class="reference internal" href="#ovito.data.NearestNeighborFinder" title="ovito.data.NearestNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code></a> class instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – </p></li>
<li><p><strong>data_collection</strong> (<a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><em>DataCollection</em></a>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.CutoffNeighborFinder.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.find" title="Permalink to this definition"></a></dt>
<dd><p>Returns an iterator over all neighbors of the given particle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – The zero-based index of the central particle whose neighbors should be enumerated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A Python iterator that visits all neighbors of the central particle within the cutoff distance.
For each neighbor the iterator returns an object with the following property fields:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The zero-based global index of the current neighbor particle.</p></li>
<li><p><strong>distance</strong>: The distance of the current neighbor from the central particle.</p></li>
<li><p><strong>distance_squared</strong>: The squared neighbor distance.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector connecting the central particle with the current neighbor (taking into account periodicity).</p></li>
<li><p><strong>pbc_shift</strong>: The periodic shift vector, which specifies how often each periodic boundary of the simulation cell is crossed when going from the central particle to the current neighbor.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>The <cite>index</cite> value returned by the iterator can be used to look up properties of the neighbor particle, as demonstrated in the example above.</p>
<p>Note that all periodic images of particles within the cutoff radius are visited. Thus, the same particle index may appear multiple times in the neighbor
list of the central particle. In fact, the central particle may be among its own neighbors in a small periodic simulation cell.
However, the computed vector (<code class="docutils literal notranslate"><span class="pre">delta</span></code>) and PBC shift (<code class="docutils literal notranslate"><span class="pre">pbc_shift</span></code>) will be unique for each visited image of the neighbor particle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.CutoffNeighborFinder.find_all">
<span class="sig-name descname"><span class="pre">find_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_by</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.find_all" title="Permalink to this definition"></a></dt>
<dd><p>This is a vectorized version of the <a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find" title="ovito.data.CutoffNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method, computing the neighbor lists and neighbor vectors of several particles in a single operation.
Thus, this method can help you avoid a slow, nested Python loop in your code and it will make use of all available processor cores.
You can request the neighbor lists for the whole system in one go, or just for a specific subset of particles given by <em>indices</em>.</p>
<p>The method produces a uniform array of neighbor list entries. Each entry comprises a pair of indices, i.e. the central particle and one of its neighboring particles within the cutoff distance,
and the corresponding spatial neighbor vector in 3d Cartesian coordinates. For best performance, the method returns all neighbors of all particles as one large
array, which is unsorted by default (<em>sort_by</em> = <code class="docutils literal notranslate"><span class="pre">None</span></code>). That means the neighbors of central particles will <em>not</em> form contiguous blocks in the output array;
entries belonging to different central particles may rather appear in intermingled order!</p>
<p>Set <em>sort_by</em> to <code class="docutils literal notranslate"><span class="pre">'index'</span></code> to request grouping the entries in the output array based on the central particle index.
That means each particle’s neighbor list will be output as a contiguous block. All blocks are stored back-to-back in the output array
in ascending order of the central particle index or, if parameter <em>indices</em> was specified, in that order.
The ordering of neighbor entries within each block will still be arbitrary though. To change this, set <em>sort_by</em> to <code class="docutils literal notranslate"><span class="pre">'distance'</span></code>, which additionally
sorts the neighbors of each particle by increasing distance.</p>
<p>The method returns two NumPy arrays:</p>
<p><code class="docutils literal notranslate"><span class="pre">neigh_idx</span></code> : Array of shape (<em>M</em>, <em>2</em>) containing pairs of indices of neighboring particles, with <em>M</em> equal to the
total number of neighbors in the system. Note that the array will contain symmetric entries (<em>a</em>, <em>b</em>) and (<em>b</em>, <em>a</em>) if
neighbor list computation was requested for both particles <em>a</em> and <em>b</em> and they are within reach of each other.</p>
<p><code class="docutils literal notranslate"><span class="pre">neigh_vec</span></code> : Array of shape (<em>M</em>, 3) containing the xyz components of the Cartesian neighbor vectors (“delta”),
which connect the <em>M</em> particle pairs stored in <code class="docutils literal notranslate"><span class="pre">neigh_idx</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> – List of zero-based indices of central particles for which the neighbor lists should be computed.
If left unspecified, neighbor lists will be computed for every particle in the system.</p></li>
<li><p><strong>sort_by</strong> – One of <em>“index”</em> or <em>“distance”</em>. Requests ordering of the output arrays based on central particle index and, optionally, neighbor distance.
If left unspecified, neighbor list entries will be returned in completely arbitrary order.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">(neigh_idx,</span> <span class="pre">neigh_vec)</span></code></p>
</dd>
</dl>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Sorting of neighbor lists will incur an additional runtime cost and should only be requested if necessary.
In any case, however, this vectorized method will be much faster than an equivalent Python for-loop invoking the
<a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find" title="ovito.data.CutoffNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method for each individual particle.</p>
</div>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>The same index pair (<em>a</em>, <em>b</em>) may appear multiple times in the list <code class="docutils literal notranslate"><span class="pre">neigh_idx</span></code> if the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> uses periodic boundary
conditions and its size is smaller than twice the neighbor cutoff radius. Note that, in such a case, the corresponding neighbor vectors in <code class="docutils literal notranslate"><span class="pre">neigh_vec</span></code>
will still be unique, because they are computed for each periodic image of the neighbor <em>b</em>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.8.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.CutoffNeighborFinder.find_at">
<span class="sig-name descname"><span class="pre">find_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.find_at" title="Permalink to this definition"></a></dt>
<dd><p>Returns an iterator over all particles located within the spherical range of the given center position. In contrast to <a class="reference internal" href="#ovito.data.CutoffNeighborFinder.find" title="ovito.data.CutoffNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> this method can search for neighbors around arbitrary
spatial locations, which don’t have to coincide with any physical particle position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coords</strong> – A (x,y,z) coordinate triplet specifying the center location around which to search for particles.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A Python iterator enumerating all particles within the cutoff distance.
For each neighbor the iterator returns an object with the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The zero-based global index of the current neighbor particle.</p></li>
<li><p><strong>distance</strong>: The distance of the current particle from the center position.</p></li>
<li><p><strong>distance_squared</strong>: The squared distance.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector from the center to the current neighbor (taking into account periodicity).</p></li>
<li><p><strong>pbc_shift</strong>: The periodic shift vector, which specifies how often each periodic boundary of the simulation cell is crossed when going from the center point to the current neighbor.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>The index value returned by the iterator can be used to look up properties of the neighbor particle, as demonstrated in the example above.</p>
<p>Note that all periodic images of particles within the cutoff radius are visited. Thus, the same particle index may appear multiple times in the neighbor list.
However, the computed vector (<code class="docutils literal notranslate"><span class="pre">delta</span></code>) and image offset (<code class="docutils literal notranslate"><span class="pre">pbc_shift</span></code>) will be unique for each visited image of a neighbor particle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.CutoffNeighborFinder.neighbor_distances">
<span class="sig-name descname"><span class="pre">neighbor_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.neighbor_distances" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of distances between some central particle and all its neighbors within the cutoff range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – The 0-based index of the central particle whose neighbors should be enumerated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>NumPy array containing the radial distances to all neighbor particles within the cutoff range (in arbitrary order).</p>
</dd>
</dl>
<p>This method is equivalent to the following code, but performance is typically a lot better:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbor_distances</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.CutoffNeighborFinder.neighbor_vectors">
<span class="sig-name descname"><span class="pre">neighbor_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.CutoffNeighborFinder.neighbor_vectors" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of vectors from some central particle to all its neighbors within the cutoff range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – The 0-based index of the central particle whose neighbors should be enumerated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Two-dimensional NumPy array containing the vectors to all neighbor particles within the cutoff range (in arbitrary order).</p>
</dd>
</dl>
<p>The method is equivalent to the following code, but performance is typically a lot better:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">neighbor_vectors</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="n">vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.DataCollection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">DataCollection</span></span><a class="headerlink" href="#ovito.data.DataCollection" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code> is a container class holding together individual <em>data objects</em>, each representing different fragments of a dataset. For example, a dataset loaded from a simulation data file may consist of particles, the simulation cell information and additional auxiliary data such as the current timestep number of the snapshots, etc. All this information is contained in one <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code>, which exposes the individual pieces of information as sub-objects, for example, via the <a class="reference internal" href="#ovito.data.DataCollection.particles" title="ovito.data.DataCollection.particles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.particles</span></code></a>, <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.cell</span></code></a> and <a class="reference internal" href="#ovito.data.DataCollection.attributes" title="ovito.data.DataCollection.attributes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.attributes</span></code></a> fields.</p>
<p>Data collections are the elementary entities that get processed within a data <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a>. Each modifier receives a data collection from the preceding modifier, alters it in some way, and passes it on to the next modifier. The output data collection of the last modifier in the pipeline is returned by the <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline.compute" title="ovito.pipeline.Pipeline.compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Pipeline.compute()</span></code></a> method.</p>
<p>A data collection essentially consists of a bunch of <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObjects</span></code></a>, which are all stored in the <a class="reference internal" href="#ovito.data.DataCollection.objects" title="ovito.data.DataCollection.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.objects</span></code></a> list. Typically, you don’t access the data objects through this list directly but rather use one of the special accessor fields provided by the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code> class, which give more convenient access to data objects of a particular kind. For example, the <a class="reference internal" href="#ovito.data.DataCollection.surfaces" title="ovito.data.DataCollection.surfaces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">surfaces</span></code></a> dictionary provides key-based access to all the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> instances currently in the data collection.</p>
<p>You can programmatically add or remove data objects from a data collection by manipulating its <a class="reference internal" href="#ovito.data.DataCollection.objects" title="ovito.data.DataCollection.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a> list. For instance, to populate a new data collection instance that is initially empty with a new <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">DataCollection</span><span class="p">()</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">SimulationCell</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DataCollection.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">modifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataCollection.apply" title="Permalink to this definition"></a></dt>
<dd><p>This method applies a <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Modifier" title="ovito.pipeline.Modifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Modifier</span></code></a> function to the data stored in this collection to modify it in place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>modifier</strong> (<a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Modifier" title="ovito.pipeline.Modifier"><em>ovito.pipeline.Modifier</em></a>) – The modifier object that should alter the contents of this data collection in place.</p></li>
<li><p><strong>frame</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – Optional animation frame number to be passed to the modifier function, which may use it for time-dependent modifications.</p></li>
</ul>
</dd>
</dl>
<p>The method allows modifying a data collection with one of OVITO’s modifiers directly without the need to build up a complete
<a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> first. In contrast to a <a class="reference internal" href="../introduction/pipelines.html#modifiers-overview"><span class="std std-ref">data pipeline</span></a>, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> method
executes the modifier function immediately and alters the data in place. In other words, the original data in this <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>
gets replaced by the output produced by the invoked modifier function. It is possible to first create a copy of
the original data using the <a class="reference internal" href="#ovito.data.DataCollection.clone" title="ovito.data.DataCollection.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> method if needed. The following code example
demonstrates how to use <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> to successively modify a dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="kn">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">CoordinationAnalysisModifier</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="mf">2.9</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ExpressionSelectionModifier</span><span class="p">(</span><span class="n">expression</span><span class="o">=</span><span class="s2">&quot;Coordination&lt;9&quot;</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">DeleteSelectedModifier</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that it is typically possible to achieve the same result by first populating a <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> with the modifiers and then calling its
<a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline.compute" title="ovito.pipeline.Pipeline.compute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute()</span></code></a> method at the very end:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CoordinationAnalysisModifier</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="mf">2.9</span><span class="p">))</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExpressionSelectionModifier</span><span class="p">(</span><span class="n">expression</span><span class="o">=</span><span class="s2">&quot;Coordination&lt;9&quot;</span><span class="p">))</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DeleteSelectedModifier</span><span class="p">())</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
<p>An important use case of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> method is in the implementation of a <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">user-defined modifier function</span></a>,
making it possible to invoke other modifiers as sub-routines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># A user-defined modifier function that calls the built-in ColorCodingModifier</span>
<span class="c1"># as a sub-routine to assign a color to each atom based on some property</span>
<span class="c1"># created within the function itself:</span>
<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DataCollection</span><span class="p">):</span>
    <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;idx&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ColorCodingModifier</span><span class="p">(</span><span class="nb">property</span><span class="o">=</span><span class="s1">&#39;idx&#39;</span><span class="p">),</span> <span class="n">frame</span><span class="p">)</span>

<span class="c1"># Set up a data pipeline that uses the user-defined modifier function:</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modify</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.attributes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">attributes</span></span><a class="headerlink" href="#ovito.data.DataCollection.attributes" title="Permalink to this definition"></a></dt>
<dd><p>This field contains a dictionary view with all the <em>global attributes</em> currently associated with this data collection.
Global attributes are key-value pairs that represent small tokens of information, typically simple value types such as <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">str</span></code>.
Every attribute has a unique identifier such as <code class="docutils literal notranslate"><span class="pre">'Timestep'</span></code> or <code class="docutils literal notranslate"><span class="pre">'ConstructSurfaceMesh.surface_area'</span></code>. This identifier serves as lookup key in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">attributes</span></code> dictionary.
Attributes are dynamically generated by modifiers in a data pipeline or come from the data source.
For example, if the input simulation file contains timestep information, the timestep number is made available by the <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.FileSource" title="ovito.pipeline.FileSource"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FileSource</span></code></a> as the
<code class="docutils literal notranslate"><span class="pre">'Timestep'</span></code> attribute. It can be retrieved from pipeline’s output data collection:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s1">&#39;snapshot_140000.dump&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;Timestep&#39;</span><span class="p">]</span>
<span class="go">140000</span>
</pre></div>
</div>
<p>Some modifiers report their calculation results by adding new attributes to the data collection. See each modifier’s
reference documentation for the list of attributes it generates. For example, the number of clusters identified by the
<a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ClusterAnalysisModifier" title="ovito.modifiers.ClusterAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClusterAnalysisModifier</span></code></a> is available in the pipeline output as an attribute named
<code class="docutils literal notranslate"><span class="pre">ClusterAnalysis.cluster_count</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ClusterAnalysisModifier</span><span class="p">(</span><span class="n">cutoff</span> <span class="o">=</span> <span class="mf">3.1</span><span class="p">))</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="n">nclusters</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;ClusterAnalysis.cluster_count&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">ovito.io.export_file()</span></code></a> function can be used to output dynamically computed attributes to a text file, possibly as functions of time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s2">&quot;data.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;txt/attr&quot;</span><span class="p">,</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Timestep&quot;</span><span class="p">,</span> <span class="s2">&quot;ClusterAnalysis.cluster_count&quot;</span><span class="p">],</span>
    <span class="n">multiple_frames</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>If you are writing your own <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">modifier function</span></a>, you let it add new attributes to a data collection.
In the following example, the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CommonNeighborAnalysisModifier" title="ovito.modifiers.CommonNeighborAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommonNeighborAnalysisModifier</span></code></a> first inserted into the
pipeline generates the <code class="docutils literal notranslate"><span class="pre">'CommonNeighborAnalysis.counts.FCC'</span></code> attribute to report the number of atoms that
have an FCC-like coordination. To compute an atomic <em>fraction</em> from that, we need to divide the count by the total number of
atoms in the system. To this end, we append a user-defined modifier function
to the pipeline, which computes the fraction and outputs the value as a new attribute named <code class="docutils literal notranslate"><span class="pre">'fcc_fraction'</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CommonNeighborAnalysisModifier</span><span class="p">())</span>
            
<span class="k">def</span> <span class="nf">compute_fcc_fraction</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">n_fcc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;CommonNeighborAnalysis.counts.FCC&#39;</span><span class="p">]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;fcc_fraction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_fcc</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span>

<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_fcc_fraction</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;fcc_fraction&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.cell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cell</span></span><a class="headerlink" href="#ovito.data.DataCollection.cell" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> data object describing the cell vectors and periodic boundary
condition flags. It may be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> data object returned by this attribute may be marked as read-only,
which means your attempts to modify the cell object will raise a Python error.
This is typically the case if the data collection was produced by a pipeline and its objects are owned by the system.</p>
</div>
<p>If you intend to modify the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> data object within this data collection, use the <code class="xref py py-attr docutils literal notranslate"><span class="pre">cell_</span></code>
attribute instead to explicitly request a mutable version of the cell object. See topic <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">Announcing object modification</span></a> for more information.
Use <code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code> for read access and <code class="xref py py-attr docutils literal notranslate"><span class="pre">cell_</span></code> for write access, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> in a data collection that might not have a simulation cell yet, use the
<a class="reference internal" href="#ovito.data.DataCollection.create_cell" title="ovito.data.DataCollection.create_cell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_cell()</span></code></a> method or simply assign a new instance of the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> class to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code> attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DataCollection.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataCollection.clone" title="Permalink to this definition"></a></dt>
<dd><p>Returns a copy of this <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> containing the same data objects as the original.</p>
<p>The method may be used to retain a copy of the original data before modifying a data collection in place,
for example using the <a class="reference internal" href="#ovito.data.DataCollection.apply" title="ovito.data.DataCollection.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">original</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ExpressionSelectionModifier</span><span class="p">(</span><span class="n">expression</span><span class="o">=</span><span class="s2">&quot;Position.Z &lt; 0&quot;</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">DeleteSelectedModifier</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of atoms before:&quot;</span><span class="p">,</span> <span class="n">original</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of atoms after:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the <code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code> method performs an inexpensive, shallow copy, meaning that the newly created collection will still share
the data objects with the original collection. Data objects that are shared by two or more data collections are
protected against modification by default to avoid unwanted side effects.
Thus, in order to subsequently modify the data objects in either the original collection or its
copy, you will have to use the underscore notation or the <a class="reference internal" href="#ovito.data.DataObject.make_mutable" title="ovito.data.DataObject.make_mutable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataObject.make_mutable()</span></code></a> method to explicitly
request a deep copy of the particular data object(s) you want to modify. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">copy</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
<span class="c1"># Data objects are shared by original and copy:</span>
<span class="k">assert</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

<span class="c1"># In order to modify the SimulationCell in the dataset copy, we must request</span>
<span class="c1"># a mutable version of the SimulationCell using the &#39;cell_&#39; accessor:</span>
<span class="n">copy</span><span class="o">.</span><span class="n">cell_</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># As a result, the cell object in the second data collection has been replaced</span>
<span class="c1"># with a deep copy and the two data collections no longer share the same</span>
<span class="c1"># simulation cell object:</span>
<span class="k">assert</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DataCollection.create_cell">
<span class="sig-name descname"><span class="pre">create_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(True,</span> <span class="pre">True,</span> <span class="pre">True)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vis_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataCollection.create_cell" title="Permalink to this definition"></a></dt>
<dd><p>This convenience method conditionally creates a new <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object and stores it in this data collection.
If a simulation cell already existed in the collection (<a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>), then that cell object is
replaced with a <a class="reference internal" href="../introduction/data_manipulation.html#data-ownership"><span class="std std-ref">modifiable copy</span></a> if necessary and the matrix and PBC flags are set to the given values.
The attached <a class="reference internal" href="ovito_vis.html#ovito.vis.SimulationCellVis" title="ovito.vis.SimulationCellVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCellVis</span></code></a> element is maintained in this case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> – A 3x4 array to initialize the cell matrix with. It specifies the three cell vectors and the origin.</p></li>
<li><p><strong>pbc</strong> – A tuple of three Booleans specifying the cell’s <a class="reference internal" href="#ovito.data.SimulationCell.pbc" title="ovito.data.SimulationCell.pbc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc</span></code></a> flags.</p></li>
<li><p><strong>vis_params</strong> (<em>Mapping</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>Any</em><em>]</em>) – Optional dictionary to initialize attributes of the attached <a class="reference internal" href="ovito_vis.html#ovito.vis.SimulationCellVis" title="ovito.vis.SimulationCellVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCellVis</span></code></a> element (only used if the cell object is newly created by the method).</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell">ovito.data.SimulationCell</a></p>
</dd>
</dl>
<p>The logic of this method is roughly equivalent to the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_cell</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataCollection</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">pbc</span><span class="p">,</span> <span class="n">vis_params</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SimulationCell</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">SimulationCell</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">line_width</span> <span class="o">=</span> <span class="o">&lt;...&gt;</span> <span class="c1"># Some value that scales with the cell&#39;s size</span>
        <span class="k">if</span> <span class="n">vis_params</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">vis_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">cell_</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../introduction/examples/modifiers/shrink_wrap_box.html#example-shrink-wrap-box"><span class="std std-ref">Example M5: Shrink-wrap simulation box</span></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DataCollection.create_particles">
<span class="sig-name descname"><span class="pre">create_particles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataCollection.create_particles" title="Permalink to this definition"></a></dt>
<dd><p>This convenience method conditionally creates a new <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> container object and stores it in this data collection.
If the data collection already contains an existing particles object (<a class="reference internal" href="#ovito.data.DataCollection.particles" title="ovito.data.DataCollection.particles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">particles</span></code></a> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>), then that particles object is
replaced with a <a class="reference internal" href="../introduction/data_manipulation.html#data-ownership"><span class="std std-ref">modifiable copy</span></a> if necessary. The associated <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis" title="ovito.vis.ParticlesVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticlesVis</span></code></a> element is preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Key/value pairs passed to the method as keyword arguments are used to set attributes of the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object (even if the particles object already existed).</p></li>
<li><p><strong>vis_params</strong> (<em>Mapping</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>Any</em><em>]</em>) – Optional dictionary to initialize attributes of the attached <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis" title="ovito.vis.ParticlesVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticlesVis</span></code></a> element (only used if the particles object is newly created by the method).</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles">ovito.data.Particles</a></p>
</dd>
</dl>
<p>The logic of this method is roughly equivalent to the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_particles</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataCollection</span><span class="p">,</span> <span class="n">vis_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Particles</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">particles</span> <span class="o">=</span> <span class="n">Particles</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vis_params</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">vis_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span>
</pre></div>
</div>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mf">0.06</span><span class="p">,</span>  <span class="mf">1.83</span><span class="p">,</span>  <span class="mf">0.81</span><span class="p">),</span> <span class="c1"># xyz coordinates of the 3 particle system to create</span>
          <span class="p">(</span> <span class="mf">1.79</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.88</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.11</span><span class="p">),</span>
          <span class="p">(</span><span class="o">-</span><span class="mf">1.73</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.77</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.61</span><span class="p">)]</span>
<span class="n">particles</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_particles</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">vis_params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;radius&#39;</span><span class="p">:</span> <span class="mf">1.4</span><span class="p">})</span>
<span class="n">particles</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Position&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.4.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.dislocations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dislocations</span></span><a class="headerlink" href="#ovito.data.DataCollection.dislocations" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a> data object; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if there
is no object of this type in the collection. Typically, the <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a> is created by a <a class="reference internal" href="../introduction/pipelines.html#modifiers-overview"><span class="std std-ref">pipeline</span></a>
containing the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.DislocationAnalysisModifier" title="ovito.modifiers.DislocationAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationAnalysisModifier</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.grids">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">grids</span></span><a class="headerlink" href="#ovito.data.DataCollection.grids" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary view providing key-based access to all <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrids</span></code></a> in
this data collection. Each <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key,
which allows you to look it up in this dictionary. To find out which voxel grids exist in the data collection and what
their identifiers are, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">grids</span><span class="p">)</span>
</pre></div>
</div>
<p>Then retrieve the desired <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> from the collection using its identifier key, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">charge_density_grid</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">grids</span><span class="p">[</span><span class="s1">&#39;charge-density&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">charge_density_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>The view provides the convenience method <code class="xref py py-meth docutils literal notranslate"><span class="pre">grids.create()</span></code>, which
inserts a newly created <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> into the data collection. The method expects the unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a>
of the new grid as first argument. All other keyword arguments are forwarded to the constructor
to initialize the member fields of the <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
    <span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Field&quot;</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">domain</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
<p>If there is already an existing grid with the same <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> in the collection, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code>
method modifies and returns that existing grid instead of creating another one.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.lines">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lines</span></span><a class="headerlink" href="#ovito.data.DataCollection.lines" title="Permalink to this definition"></a></dt>
<dd><p>A dictionary view providing key-based access to all <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> objects in
this data collection. Each <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key,
which can be used to look it up in the dictionary. You can use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span>
</pre></div>
</div>
<p>to see which identifiers exist. Then retrieve the desired <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object from the collection using its identifier
key, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lines</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="s2">&quot;trajectories&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="s2">&quot;Position&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object with the identifier <code class="docutils literal notranslate"><span class="pre">&quot;trajectories&quot;</span></code>, for example, is the one that gets
created by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.GenerateTrajectoryLinesModifier" title="ovito.modifiers.GenerateTrajectoryLinesModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateTrajectoryLinesModifier</span></code></a>.</p>
<p>If you would like to create a new <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object, in a user-defined modifier for instance,
the dictionary view provides the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">lines.create()</span></code>, which
creates a new <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> and adds it to the data collection. The method expects the unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a>
of the new lines object as first argument. All other keyword arguments are forwarded to the class constructor
to initialize the member fields of the <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lines</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;mylines&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If there is already an existing <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object with the same <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> in the collection, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code>
method returns that object instead of creating another one and makes sure it can be safely modified.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.objects">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objects</span></span><a class="headerlink" href="#ovito.data.DataCollection.objects" title="Permalink to this definition"></a></dt>
<dd><p>Flat list of all top-level <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObjects</span></code></a> currently in this data collection. You can add or remove data objects from this list as needed.</p>
<p>Typically, however, you don’t need to work with this list directly, because the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code> class provides several convenience accessor attributes for the different flavors of data objects in OVITO. For example, <a class="reference internal" href="#ovito.data.DataCollection.particles" title="ovito.data.DataCollection.particles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.particles</span></code></a> returns the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object (by looking it up in the <a class="reference internal" href="#ovito.data.DataCollection.objects" title="ovito.data.DataCollection.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a> list for you). Dictionary-like views such as <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a> and <a class="reference internal" href="#ovito.data.DataCollection.surfaces" title="ovito.data.DataCollection.surfaces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.surfaces</span></code></a> provide key-based access to a particular class of data objects in the collection.</p>
<p>To add new objects to the data collection, you can append them to the <a class="reference internal" href="#ovito.data.DataCollection.objects" title="ovito.data.DataCollection.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a> list or, more conveniently, use creation functions such as <a class="reference internal" href="#ovito.data.DataCollection.create_particles" title="ovito.data.DataCollection.create_particles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_particles()</span></code></a>, <a class="reference internal" href="#ovito.data.DataCollection.create_cell" title="ovito.data.DataCollection.create_cell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_cell()</span></code></a>, or <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tables.create()</span></code></a>, which are provided by the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> class.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.particles">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">particles</span></span><a class="headerlink" href="#ovito.data.DataCollection.particles" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object, which manages all <a class="reference internal" href="../introduction/data_model.html#particle-properties-intro"><span class="std std-ref">per-particle properties</span></a>.
It may be <code class="docutils literal notranslate"><span class="pre">None</span></code> if the data collection contains no particle model at all.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> data object returned by this attribute may be marked as read-only,
which means attempts to modify its contents will raise a Python error.
This is typically the case if the data collection was produced by a pipeline and all data objects are owned by the system.</p>
</div>
<p>If you intend to modify the contents of the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object in some way, use the <code class="xref py py-attr docutils literal notranslate"><span class="pre">particles_</span></code>
attribute instead to explicitly request a mutable version of the particles object. See topic <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">Announcing object modification</span></a> for more information.
Use <code class="xref py py-attr docutils literal notranslate"><span class="pre">particles</span></code> for read access and <code class="xref py py-attr docutils literal notranslate"><span class="pre">particles_</span></code> for write access, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">positions_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a new <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object in a data collection that might not have particles yet, use the
<a class="reference internal" href="#ovito.data.DataCollection.create_particles" title="ovito.data.DataCollection.create_particles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_particles()</span></code></a> method or simply assign a new instance of the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> class to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">particles</span></code> attribute.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.surfaces">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">surfaces</span></span><a class="headerlink" href="#ovito.data.DataCollection.surfaces" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary view providing key-based access to all <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> objects in
this data collection. Each <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key,
which can be used to look it up in the dictionary.
See the documentation of the modifier producing the surface mesh to find out what the right key is, or use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="p">)</span>
</pre></div>
</div>
<p>to see which identifier keys exist. Then retrieve the desired <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> object from the collection using its identifier
key, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The view provides the convenience method <code class="xref py py-meth docutils literal notranslate"><span class="pre">surfaces.create()</span></code>, which
inserts a newly created <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> into the data collection. The method expects the unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a>
of the new surface mesh as first argument. All other keyword arguments are forwarded to the constructor
to initialize the member fields of the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
    <span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;surface&quot;</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;A surface mesh&quot;</span><span class="p">,</span>
    <span class="n">domain</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
<p>If there is already an existing mesh with the same <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> in the collection, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code>
method modifies and returns that existing mesh instead of creating another one.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.tables">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tables</span></span><a class="headerlink" href="#ovito.data.DataCollection.tables" title="Permalink to this definition"></a></dt>
<dd><p>A dictionary view of all <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> objects in
this data collection. Each <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key,
which allows it to be looked up in this dictionary. Use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="p">)</span>
</pre></div>
</div>
<p>to find out which table identifiers are present in the data collection.
Then use the identifier to retrieve the desired <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> from the dictionary, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rdf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="s1">&#39;coordination-rdf&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rdf</span><span class="o">.</span><span class="n">xy</span><span class="p">())</span>
</pre></div>
</div>
<p>The view provides the convenience method <code class="xref py py-meth docutils literal notranslate"><span class="pre">tables.create()</span></code>, which
inserts a newly created <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> into the data collection. The method expects the unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a>
of the new data table as first argument. All other keyword arguments are forwarded to the constructor
to initialize the member fields of the <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Code example showing how to compute a histogram of the particles&#39; x-coordinates within some interval.</span>
<span class="n">x_interval</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">)</span>
<span class="n">x_coords</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">histogram</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">x_interval</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Output the histogram as a new DataTable, which makes it appear in OVITO&#39;s data inspector panel:</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
    <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;binning&#39;</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Binned particle counts&#39;</span><span class="p">,</span>
    <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Histogram</span><span class="p">,</span>
    <span class="n">interval</span><span class="o">=</span><span class="n">x_interval</span><span class="p">,</span>
    <span class="n">axis_label_x</span><span class="o">=</span><span class="s1">&#39;Position X&#39;</span><span class="p">,</span>
    <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">histogram</span><span class="p">))</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Particle count&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">histogram</span><span class="p">)</span>
</pre></div>
</div>
<p>If there is already an existing table with the same <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> in the collection, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code>
method modifies and returns that existing table instead of creating another one.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataCollection.triangle_meshes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">triangle_meshes</span></span><a class="headerlink" href="#ovito.data.DataCollection.triangle_meshes" title="Permalink to this definition"></a></dt>
<dd><p>This is a dictionary view providing key-based access to all <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> objects currently stored in
this data collection. Each <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> key,
which can be used to look it up in the dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.DataObject">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">DataObject</span></span><a class="headerlink" href="#ovito.data.DataObject" title="Permalink to this definition"></a></dt>
<dd><p>Abstract base class for all data object types in OVITO.</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code> represents a fragment of data processed in or by a data pipeline. 
See the <a class="reference internal" href="#module-ovito.data" title="ovito.data"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ovito.data</span></code></a> module for a list of different concrete data object types in OVITO. 
Data objects are typically contained in a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>, 
which represents a whole <em>data set</em>. Furthermore, data objects can be nested into a hierarchy. 
For example, the <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> data object is part of the parent <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> data object.</p>
<p>Data objects by themselves are non-visual objects. Visualizing the information stored in a data object in images 
is the responsibility of so-called <a class="reference internal" href="../introduction/rendering.html#rendering-visual-elements"><span class="std std-ref">visual elements</span></a>.
A data object may be associated with a <a class="reference internal" href="ovito_vis.html#ovito.vis.DataVis" title="ovito.vis.DataVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataVis</span></code></a> element by assigning it to the data object’s <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> field. 
Each type of visual element exposes a set of parameters that allow you to configure the appearance of the 
data visualization in rendered images and animations.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../introduction/data_model.html#data-model-intro"><span class="std std-ref">Data model</span></a></p>
<p><a class="reference internal" href="../introduction/rendering.html#rendering-visual-elements"><span class="std std-ref">Visual elements</span></a></p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataObject.identifier">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identifier</span></span><a class="headerlink" href="#ovito.data.DataObject.identifier" title="Permalink to this definition"></a></dt>
<dd><p>The unique identifier string of the data object. It serves as lookup key in object dictionaries, for example the <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a> collection, or as a target name in various places where a data object needs to be referenced by name, e.g. the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.TimeAveragingModifier.operate_on" title="ovito.modifiers.TimeAveragingModifier.operate_on"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TimeAveragingModifier.operate_on</span></code></a> field.</p>
<p>Data objects generated by modifiers in a pipeline typically have an automatically assigned identifier, as documented in the description of the respective modifier. When writing your own <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">modifier function</span></a>, you are responsible for giving new data objects created by your modifier function a meaningful identifier, so that subsequent modifiers in the pipeline can refer to these data objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DataObject.make_mutable">
<span class="sig-name descname"><span class="pre">make_mutable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subobj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataObject.make_mutable" title="Permalink to this definition"></a></dt>
<dd><p>This helper method requests a deep copy of <em>subobj</em>, which must be a child <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code> of this parent <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code>. A copy will only be made in case the sub-object is currently referenced by at least one more parent object. If, however, the sub-object is exclusively owned by this <code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code>, no copy is made and the original sub-object is returned as is. The returned object is safe to modify without unexpected side effects, because any shared ownership is converted to an exclusive ownership by the method.</p>
<p>Please see the section <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">Announcing object modification</span></a> for a discussion of object ownership and typical use cases for this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>subobj</strong> (<a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><em>DataObject</em></a>) – A existing sub-object of this parent data object, for which exclusive ownership is requested.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A copy of <em>subobj</em> if its ownership was previously shared with some other parent. Otherwise the original object is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataObject.vis">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vis</span></span><a class="headerlink" href="#ovito.data.DataObject.vis" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="ovito_vis.html#ovito.vis.DataVis" title="ovito.vis.DataVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataVis</span></code></a> element currently associated with this data object, which is responsible for visually rendering the stored data. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the data object remains non-visual and doesn’t appear in rendered images or the viewports. Furthermore, note that the same <a class="reference internal" href="ovito_vis.html#ovito.vis.DataVis" title="ovito.vis.DataVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataVis</span></code></a> element may be assigned to multiple data objects in order to synchronize their visual appearance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.DataTable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">DataTable</span></span><a class="headerlink" href="#ovito.data.DataTable" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
<p>This data object type in OVITO represents a series of data points and is primarily used for histogram plots and other 2d graphs.
More generally, however, it can store tabulated data consisting of an arbitrary number of columns of numeric values.</p>
<p>When used for 2d plots, a <a class="reference internal" href="../introduction/data_model.html#data-tables-intro"><span class="std std-ref">data table</span></a> consists of an array of y-values and, optionally, an array of corresponding x-values,
one value pair for each data point. These arrays are regular <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> objects managed by the data table (a sub-class of <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>).</p>
<p>If no <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> data array has been set, the x-coordinates of the data points are implicitly determined by the table’s
<a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>, which specifies a range along the x-axis over which the data points are evenly distributed.
This is used, for example, for histograms with equisized bins, which don’t require explicit x-coordinates.</p>
<p>Data tables generated by modifiers such as <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CoordinationAnalysisModifier" title="ovito.modifiers.CoordinationAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinationAnalysisModifier</span></code></a> and <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.HistogramModifier" title="ovito.modifiers.HistogramModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistogramModifier</span></code></a>
are accessible via the <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a> dictionary. You can retrieve them based on their
unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="p">)</span>  <span class="c1"># Print list of available data tables</span>
<span class="go">{&#39;coordination-rdf&#39;: DataTable(), &#39;clusters&#39;: DataTable()}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rdf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="s1">&#39;coordination-rdf&#39;</span><span class="p">]</span>  <span class="c1"># Look up tabulated RDF produced by a CoordinationAnalysisModifier</span>
</pre></div>
</div>
<p>Exporting the values in a data table to a simple text file is possible using the <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_file()</span></code></a> function (use file format <code class="docutils literal notranslate"><span class="pre">txt/table</span></code>).
You can either export a single <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a> or, as in the following code example, write a series of text files
to export all the tables generated by a <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> for a simulation trajectory in one go. The <code class="docutils literal notranslate"><span class="pre">key</span></code> parameter
selects which table from the <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.tables</span></code></a> dict is to be exported based on its
unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s1">&#39;output/rdf.*.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;txt/table&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;coordination-rdf&#39;</span><span class="p">,</span> <span class="n">multiple_frames</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>To programatically create a new data table in Python, you should use the <a class="reference internal" href="#ovito.data.DataCollection.tables" title="ovito.data.DataCollection.tables"><code class="xref py py-attr docutils literal notranslate"><span class="pre">data.tables.create()</span></code></a> method,
for example when implementing a <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">custom modifier function</span></a> that should output its results as a data plot.
The following code examples demonstrate how to add a new <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code> to the data collection and fill it with values.</p>
<p>To create a simple x-y scatter point plot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a DataTable object and specify its plot type and a human-readable title:</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;myplot&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Scatter</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Scatter Plot&#39;</span><span class="p">)</span>
<span class="c1"># Set the x- and y-coordinates of the data points:</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;X coordinates&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Y coordinates&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Note how the <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> method is being used here to create two <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a>
objects storing the coordinates of the data points. These property objects are then set as <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> and <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> arrays
of the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code>. This is necessary because a data table is a general <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>, which can store an arbitrary
number of data columns. We have to tell the table which of these properties should be used as x- and y-coordinates for plotting.</p>
<p>A multi-line plot is obtained by using a <em>vectorial</em> property for the <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> array of the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;plot&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Line</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Trig functions&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Parameter x&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="c1"># Use the x-coords to compute two y-coords per data point: y(x) = (cos(x), sin(x))</span>
<span class="n">y1y2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;f(x)&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">y1y2</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cos(x)&#39;</span><span class="p">,</span> <span class="s1">&#39;sin(x)&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>To generate a bar chart, the table’s <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property must be filled with numeric IDs 0,1,2,3,… denoting the individual bars.
Each bar is then given a text label by adding an <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> to the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list
using <a class="reference internal" href="#ovito.data.Property.add_type_id" title="ovito.data.Property.add_type_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Property.add_type_id()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;chart&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">BarChart</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Bar Chart&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Structure Type&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">add_type_id</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Other&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">add_type_id</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FCC&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">add_type_id</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;HCP&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">add_type_id</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BCC&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">75</span><span class="p">])</span>
</pre></div>
</div>
<p>For histogram plots, one can specify the complete range of values covered by the histogram by setting the table’s <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a> property.
The bin counts must be stored in the table’s <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> property. The number of elements in the <a class="reference internal" href="#ovito.data.DataTable.y" title="ovito.data.DataTable.y"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y</span></code></a> property array, together with the
<a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>, determine the number of histogram bins and their uniform widths:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Histogram</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Histogram&#39;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Counts&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">75</span><span class="p">])</span>
<span class="n">table</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>   <span class="c1"># Four histogram bins of width 0.5 each.</span>
<span class="n">table</span><span class="o">.</span><span class="n">axis_label_x</span> <span class="o">=</span> <span class="s1">&#39;Values&#39;</span> <span class="c1"># Set the x-axis label of the plot.</span>
</pre></div>
</div>
<p>If you are going to access or export the data table after it was inserted into the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>,
refer to it using its unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> given at construction time, as shown in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DataCollection</span><span class="p">):</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;trig-func&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;My Plot&#39;</span><span class="p">,</span> <span class="n">plot_mode</span><span class="o">=</span><span class="n">DataTable</span><span class="o">.</span><span class="n">PlotMode</span><span class="o">.</span><span class="n">Line</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;X coords&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
    <span class="n">table</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Y coords&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">frame</span> <span class="o">*</span> <span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>

<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modify</span><span class="p">)</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s1">&#39;output/data.*.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;txt/table&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;trig-func&#39;</span><span class="p">,</span> <span class="n">multiple_frames</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataTable.axis_label_x">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">axis_label_x</span></span><a class="headerlink" href="#ovito.data.DataTable.axis_label_x" title="Permalink to this definition"></a></dt>
<dd><p>The text label of the x-axis. This string is only used for a data plot if the <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property of the data table is <code class="docutils literal notranslate"><span class="pre">None</span></code> and the x-coordinates of the data points are implicitly defined by the table’s <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a> property. Otherwise the <a class="reference internal" href="#ovito.data.Property.name" title="ovito.data.Property.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> of the <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property is used as axis label.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">''</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataTable.interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">interval</span></span><a class="headerlink" href="#ovito.data.DataTable.interval" title="Permalink to this definition"></a></dt>
<dd><p>A pair of float values specifying the x-axis interval covered by the data points in this table.
This interval is only used by the table if the data points do not possess explicit x-coordinates (i.e. if the table’s <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> property is <code class="docutils literal notranslate"><span class="pre">None</span></code>).
In the absence of explicit x-coordinates, the interval specifies the range of equispaced x-coordinates implicitly generated
by the data table.</p>
<p>Implicit x-coordinates are typically used in data tables representing histograms, which consist of equally-sized bins
covering a certain value range along the x-axis. The bin size is then given by the interval width divided by the
number of data points (see <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PropertyContainer.count</span></code></a> property). The implicit x-coordinates of data points are placed in the centers of the bins. 
You can call the table’s <a class="reference internal" href="#ovito.data.DataTable.xy" title="ovito.data.DataTable.xy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">xy()</span></code></a> method to let it explicitly calculate the x-coordinates from the value interval for every data point.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataTable.plot_mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plot_mode</span></span><a class="headerlink" href="#ovito.data.DataTable.plot_mode" title="Permalink to this definition"></a></dt>
<dd><p>The type of graphical plot for rendering the data in this <code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code>. Must be one of the following predefined constants:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.NoPlot</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Line</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Histogram</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.BarChart</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Scatter</span></code></p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">DataTable.PlotMode.Line</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataTable.x">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#ovito.data.DataTable.x" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> containing the x-coordinates of the data points (for the purpose of plotting). The data points may not have explicit x-coordinates, so this property may be <code class="docutils literal notranslate"><span class="pre">None</span></code> for a data table. In such a case, the x-coordinates of the data points are implicitly determined by the table’s <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DataTable.xy">
<span class="sig-name descname"><span class="pre">xy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DataTable.xy" title="Permalink to this definition"></a></dt>
<dd><p>This convenience method returns a two-dimensional NumPy array containing both the x- and the y-coordinates of the data points in this data table.
If the table has no explicit <a class="reference internal" href="#ovito.data.DataTable.x" title="ovito.data.DataTable.x"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x</span></code></a> coordinate property set, this method automatically computes equispaced x-coordinates from the <a class="reference internal" href="#ovito.data.DataTable.interval" title="ovito.data.DataTable.interval"><code class="xref py py-attr docutils literal notranslate"><span class="pre">interval</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DataTable.y">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">y</span></span><a class="headerlink" href="#ovito.data.DataTable.y" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> containing the y-coordinates of the data points (for the purpose of plotting). This may be a vector property having more than one component per data point, in which case this data table represents a family of data plots.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">DislocationNetwork</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>A network of dislocation lines extracted from a crystal model by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.DislocationAnalysisModifier" title="ovito.modifiers.DislocationAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationAnalysisModifier</span></code></a>.
The modifier stores the dislocation network in a pipeline’s output data collection, from where it can be retrieved via
the <a class="reference internal" href="#ovito.data.DataCollection.dislocations" title="ovito.data.DataCollection.dislocations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.dislocations</span></code></a> field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="n">network</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dislocations</span>
</pre></div>
</div>
<p>The visual appareances of the dislocation lines in rendered images and videos is controlled by the associated <a class="reference internal" href="ovito_vis.html#ovito.vis.DislocationVis" title="ovito.vis.DislocationVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationVis</span></code></a> element.
You can access it as <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> attribute of the <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a> base class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">network</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">line_width</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">network</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">coloring_mode</span> <span class="o">=</span> <span class="n">DislocationVis</span><span class="o">.</span><span class="n">ColoringMode</span><span class="o">.</span><span class="n">ByBurgersVector</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ovito.data.DislocationNetwork.lines" title="ovito.data.DislocationNetwork.lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lines</span></code></a> list gives you access to the list of individual dislocations, which are all represented by
instances of the <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork.Line</span></code></a> class. Furthermore, you can use the <a class="reference internal" href="#ovito.data.DislocationNetwork.find_nodes" title="ovito.data.DislocationNetwork.find_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_nodes()</span></code></a> method
to obtain a list of nodes at which dislocation lines are connected. These connections are represented by <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork.Connector</span></code></a>
objects.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Keep in mind that the list of dislocations is not ordered. In particular, the order
in which the DXA modifier discovers each dislocation line in the crystal will change arbitrarily from one simulation frame to the next.
Generally, there is no safe way to track individual dislocation lines through time, because dislocations (unlike atoms) don’t possess
a unique identity and are not conserved – they can nucleate, annihilate, or undergo other reactions in between trajectory frames.</p>
</div>
<p><strong>Code example</strong></p>
<p>Complete script example for loading a molecular dynamics simulation, performing the DXA on a single snapshot, printing the list of extracted dislocation lines,
and exporting the dislocation network to disk:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="kn">import</span> <span class="n">import_file</span><span class="p">,</span> <span class="n">export_file</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="kn">import</span> <span class="n">DislocationAnalysisModifier</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="kn">import</span> <span class="n">DislocationNetwork</span>

<span class="kn">import</span> <span class="nn">ovito</span>
<span class="n">ovito</span><span class="o">.</span><span class="n">enable_logging</span><span class="p">()</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>

<span class="c1"># Extract dislocation lines from a crystal with diamond structure:</span>
<span class="n">modifier</span> <span class="o">=</span> <span class="n">DislocationAnalysisModifier</span><span class="p">()</span>
<span class="n">modifier</span><span class="o">.</span><span class="n">input_crystal_structure</span> <span class="o">=</span> <span class="n">DislocationAnalysisModifier</span><span class="o">.</span><span class="n">Lattice</span><span class="o">.</span><span class="n">CubicDiamond</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modifier</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="n">total_line_length</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;DislocationAnalysis.total_line_length&#39;</span><span class="p">]</span>
<span class="n">cell_volume</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;DislocationAnalysis.cell_volume&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dislocation density: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">total_line_length</span> <span class="o">/</span> <span class="n">cell_volume</span><span class="p">))</span>

<span class="c1"># Print list of dislocation lines:</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%i</span><span class="s2"> dislocation lines&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">lines</span><span class="p">))</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dislocation </span><span class="si">%i</span><span class="s2">: length=</span><span class="si">%f</span><span class="s2">, Burgers vector=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">true_burgers_vector</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

<span class="c1"># Export dislocation lines to a CA file:</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s2">&quot;output/dislocations.ca&quot;</span><span class="p">,</span> <span class="s2">&quot;ca&quot;</span><span class="p">)</span>

<span class="c1"># Or export dislocations to a ParaView VTK file:</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="s2">&quot;output/dislocations.vtk&quot;</span><span class="p">,</span> <span class="s2">&quot;vtk/disloc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>File import and export</strong></p>
<p>Dislocation networks can be exported as a set of polylines to the <a class="reference external" href="https://docs.vtk.org/en/latest/design_documents/VTKFileFormats.html">legacy VTK file format</a> using the
<a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">ovito.io.export_file()</span></code></a> function (specify the “<cite>vtk/disloc</cite>” format).
During export to this file format, which does not support periodic boundary conditions, lines that
cross a periodic domain boundary get split (i.e., wrapped around) at the simulation box boundaries.</p>
<p>OVITO’s native format for storing dislocation networks on disk is the <a class="reference external" href="../../reference/pipelines/modifiers/dislocation_analysis.html#particles-modifiers-dislocation-analysis-fileformat" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">CA file format</span></a>,
a simple text-based format that supports periodic boundary conditions. This format can be written
by the <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_file()</span></code></a> function (”<cite>ca</cite>” format) and read by the <a class="reference internal" href="ovito_io.html#ovito.io.import_file" title="ovito.io.import_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_file()</span></code></a> function.
It stores the dislocation lines, their connectivity, as well as the “<a class="reference external" href="../../reference/pipelines/modifiers/dislocation_analysis.html#particles-modifiers-dislocation-analysis-outputs" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">defect mesh</span></a>” produced
by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.DislocationAnalysisModifier" title="ovito.modifiers.DislocationAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationAnalysisModifier</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Connector</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector" title="Permalink to this definition"></a></dt>
<dd><figure class="align-right" id="id2" style="width: 50%">
<img alt="../_images/dislocation_connectors.png" src="../_images/dislocation_connectors.png" />
<figcaption>
<p><span class="caption-text">A dislocation <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> has two end point <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.connectors" title="ovito.data.DislocationNetwork.Line.connectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">connectors</span></code></a> and
is described by a sequence of spatial <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.points" title="ovito.data.DislocationNetwork.Line.points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">points</span></code></a>.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>A connector object represents one of the two end points of each
<a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> in the network. In other words,
every <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> has exactly two unique
<a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connector</span></code></a> objects belonging to the line.
This pair is accessible via the <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.connectors" title="ovito.data.DislocationNetwork.Line.connectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Line.connectors</span></code></a>
attribute. Since dislocations always have a direction (their line sense, with respect to which their Burgers vector is defined),
one connecter is located at the “head” (forward) and one at the “tail” (backward) end of the directed line.</p>
<figure class="align-right" id="id3" style="width: 50%">
<img alt="../_images/dislocation_node.png" src="../_images/dislocation_node.png" />
<figcaption>
<p><span class="caption-text">Three dislocation arms meet at a dislocation node (junction).
The node is formed by a circular linked-list of connectors.</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>A dislocation network node (junction) is formed by several connectors located at the same point in space,
as illustrated in the figure to the right. This node structure consists of three interlinked connectors belonging
to the three dislocation arms meeting in the node. Dislocation arms can be either inbound or outbound.</p>
<p>Network nodes may consist of one, two, three or more connectors:</p>
<ol class="arabic simple">
<li><p>A single connector, only interlinked with itself, represents a dangling line end.
They occur when a dislocation terminates in another extended crystal defect, such as a grain boundary or free surface.</p></li>
<li><p>A 2-node, consisting of two interlinked connectors, is part of a dislocation loop or infinite periodic dislocation line.
They occur when a dislocation line is closed on itself, i.e, its head and tail are connected.</p></li>
<li><p>A node with three or more connectors represents a physical dislocation junction, where three or more arms with non-zero Burgers vector meet.</p></li>
</ol>
<p>The connectors belonging to the same network node are interlinked with each other in the form of a circular linked list.
The <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.next_arm" title="ovito.data.DislocationNetwork.Connector.next_arm"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connector.next_arm</span></code></a> field leads to the next connector in the circular list. The last connector of the node
points back to the first connector of the node. This way, all connectors can be visited by starting from
any connector of the node and following the <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.next_arm" title="ovito.data.DislocationNetwork.Connector.next_arm"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connector.next_arm</span></code></a> field until the starting connector is reached again.
For a 1-node (a dangling line end), the <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.next_arm" title="ovito.data.DislocationNetwork.Connector.next_arm"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connector.next_arm</span></code></a> field points to itself.</p>
<p>The <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.arms" title="ovito.data.DislocationNetwork.Connector.arms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connector.arms</span></code></a> method yields a list of all connectors belonging to the same local node as this connector
(including the connector itself). The <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.arm_count" title="ovito.data.DislocationNetwork.Connector.arm_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connector.arm_count</span></code></a> property counts the number of connectors in the local node.
The <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.line" title="ovito.data.DislocationNetwork.Connector.line"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Connector.line</span></code></a> field points to the <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> object that the connector belongs to.</p>
<p>The <a class="reference internal" href="#ovito.data.DislocationNetwork.find_nodes" title="ovito.data.DislocationNetwork.find_nodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DislocationNetwork.find_nodes()</span></code></a> method can be used to generate a list of <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connector</span></code></a>
objects, one for each node in the network. It is useful if you want to iterate over all unique nodes in the network.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.10.2.</span></p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector.arm_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">arm_count</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector.arm_count" title="Permalink to this definition"></a></dt>
<dd><p>The number of arms meeting at the node formed by this connector and others, including the connector itself.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector.arms">
<span class="sig-name descname"><span class="pre">arms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector.arms" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connector</span></code></a> objects representing the arms connected to the node. Each connector object links to a different dislocation line incident to the network node.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector.is_head">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_head</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector.is_head" title="Permalink to this definition"></a></dt>
<dd><p>True if the connector is located at the head of its dislocation line, i.e., <code class="docutils literal notranslate"><span class="pre">self</span></code> is <code class="docutils literal notranslate"><span class="pre">self.line.connectors[1]</span></code>. Then the connected <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> is inbound on the node.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector.is_tail">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_tail</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector.is_tail" title="Permalink to this definition"></a></dt>
<dd><p>True if the connector is located at the tail of its dislocation line, i.e., <code class="docutils literal notranslate"><span class="pre">self</span></code> is <code class="docutils literal notranslate"><span class="pre">self.line.connectors[0]</span></code>. Then the connected <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> is outbound from the node.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector.line">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">line</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector.line" title="Permalink to this definition"></a></dt>
<dd><p>The dislocation <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> this connector belongs to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector.next_arm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">next_arm</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector.next_arm" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connector</span></code></a> belonging to the next dislocation line incident to the node.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Connector.position">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">position</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Connector.position" title="Permalink to this definition"></a></dt>
<dd><p>The Cartesian coordinates of the connector in the global simulation coordinate system. This corresponds to the start or end point of the dislocation, i.e., either <code class="docutils literal notranslate"><span class="pre">self.line.points[0]</span></code> or <code class="docutils literal notranslate"><span class="pre">self.line.points[-1]</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The positions of the connectors in the same network node are typically identical, but   they will differ if their dislocation lines belong to different periodic images of the simulation cell.   In this case, the positions of the connectors are shifted by a periodicity vector of the simulation domain.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Line</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line" title="Permalink to this definition"></a></dt>
<dd><p>Describes a single continuous dislocation line that is part of a <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a>.</p>
<p>A dislocation line is a curve in 3d space, approximated by a sequence of <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.points" title="ovito.data.DislocationNetwork.Line.points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">points</span></code></a> connected by linear
line segments. You can query its total curve <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.length" title="ovito.data.DislocationNetwork.Line.length"><code class="xref py py-attr docutils literal notranslate"><span class="pre">length</span></code></a> or compute some location on the line
from a linear path coordinate <em>t</em> using the method <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.point_along_line" title="ovito.data.DislocationNetwork.Line.point_along_line"><code class="xref py py-meth docutils literal notranslate"><span class="pre">point_along_line()</span></code></a>.
The line is terminated by two <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.connectors" title="ovito.data.DislocationNetwork.Line.connectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">connectors</span></code></a> at its two end points, which represent the connectivity of the dislocation
network.</p>
<p>A dislocation line is embedded in some crystallite (a region with uniform lattice orientation), which is identified by the numerical <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.cluster_id" title="ovito.data.DislocationNetwork.Line.cluster_id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cluster_id</span></code></a>.
All dislocation lines belonging to the same crystallite share the same lattice coordinate system in which their <em>true Burgers vectors</em>
are expressed. A line’s <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.true_burgers_vector" title="ovito.data.DislocationNetwork.Line.true_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">true_burgers_vector</span></code></a> is given in Bravais lattice units.</p>
<p>Each crystallite has a particular mean orientation within the global simulation coordinate system and a mean lattice parameter and
elastic strain. Applying these mean crystal properties to the <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.true_burgers_vector" title="ovito.data.DislocationNetwork.Line.true_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">true_burgers_vector</span></code></a> yields the line’s <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.spatial_burgers_vector" title="ovito.data.DislocationNetwork.Line.spatial_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">spatial_burgers_vector</span></code></a>,
which is expressed in the global coordinate system shared by all dislocations of the entire <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a>.
The <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.spatial_burgers_vector" title="ovito.data.DislocationNetwork.Line.spatial_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">spatial_burgers_vector</span></code></a> is given in simulation coordinate units (typically Angstroms).</p>
<p>The <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.is_loop" title="ovito.data.DislocationNetwork.Line.is_loop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_loop</span></code></a> property flag indicates that the two end points of the dislocation line form a 2-junction. This property does not necessarily
mean that the dislocation forms an actual <em>circular</em> loop. In simulations using periodic boundary conditions, a straight dislocation can also connect to itself
through the periodic cell boundaries and form an infinite periodic line. This situation is indicated by the <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.is_infinite_line" title="ovito.data.DislocationNetwork.Line.is_infinite_line"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_infinite_line</span></code></a> property, which implies that
the <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.is_loop" title="ovito.data.DislocationNetwork.Line.is_loop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_loop</span></code></a> property is also true.</p>
<p>All fields of this class are read-only. To modify a dislocation line, you can use the <a class="reference internal" href="#ovito.data.DislocationNetwork.set_line" title="ovito.data.DislocationNetwork.set_line"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DislocationNetwork.set_line()</span></code></a> method.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 3.10.2: </span>Renamed this class from <code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationSegment</span></code> to <code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork.Line</span></code>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.cluster_id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cluster_id</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.cluster_id" title="Permalink to this definition"></a></dt>
<dd><p>The numeric identifier of the crystal cluster containing this dislocation line. Crystal cluster is the technical term for a contiguous group of atoms forming a spatial region with uniform lattice orientation, i.e., a <em>crystallite</em> or <em>grain</em>.</p>
<p>The <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.true_burgers_vector" title="ovito.data.DislocationNetwork.Line.true_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">true_burgers_vector</span></code></a> of the dislocation is expressed in the local coordinate system of the crystal cluster. The <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.spatial_burgers_vector" title="ovito.data.DislocationNetwork.Line.spatial_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">spatial_burgers_vector</span></code></a> of the dislocation is computed by transforming the true Burgers vector with the mean elastic deformation gradient tensor of the crystal cluster.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.connectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">connectors</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.connectors" title="Permalink to this definition"></a></dt>
<dd><a class="reference internal image-reference" href="../_images/dislocation_connectors.png"><img alt="../_images/dislocation_connectors.png" class="align-right" src="../_images/dislocation_connectors.png" style="width: 50%;" /></a>
<p>A tuple of two <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connector</span></code></a> objects representing the two end points of the dislocation line. The first connector is located at the start of the line (its tail), the second connector at the end of the line (its head).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.10.2.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.custom_color">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">custom_color</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.custom_color" title="Permalink to this definition"></a></dt>
<dd><p>The RGB color value to be used for visualizing this particular dislocation line, overriding the default coloring scheme imposed by the <a class="reference internal" href="ovito_vis.html#ovito.vis.DislocationVis.coloring_mode" title="ovito.vis.DislocationVis.coloring_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DislocationVis.coloring_mode</span></code></a> setting. The custom color is only used if its RGB components are non-negative (i.e. in the range 0-1); otherwise the line will be rendered using the computed color depending on the line’s Burgers vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(-1.0,</span> <span class="pre">-1.0,</span> <span class="pre">-1.0)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">id</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.id" title="Permalink to this definition"></a></dt>
<dd><p>The unique numerical identifier of this dislocation line within the <a class="reference internal" href="#ovito.data.DislocationNetwork" title="ovito.data.DislocationNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationNetwork</span></code></a>. This is simply the 0-based index of the line in the <a class="reference internal" href="#ovito.data.DislocationNetwork.lines" title="ovito.data.DislocationNetwork.lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DislocationNetwork.lines</span></code></a> list.</p>
<p>Important: This identifier is derived from the arbitrary storage order of the lines in the network and <em>cannot</em> be used to identify the same dislocation in another simulation snapshot.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.is_infinite_line">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_infinite_line</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.is_infinite_line" title="Permalink to this definition"></a></dt>
<dd><p>Indicates that this dislocation is an infinite line passing through a periodic simulation box boundary. A dislocation is considered infinite if it is a closed loop but its start and end do not coincide (because they are located in different periodic images).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.is_loop">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_loop</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.is_loop" title="Permalink to this definition"></a></dt>
<dd><p>Indicates whether this line forms a loop, i.e., its end is connected to its start point. Note that an infinite dislocation line passing through a periodic simulation cell boundary is also considered a logical loop (see <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.is_infinite_line" title="ovito.data.DislocationNetwork.Line.is_infinite_line"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_infinite_line</span></code></a> property).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.length">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">length</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.length" title="Permalink to this definition"></a></dt>
<dd><p>Computes the length of this dislocation line in simulation units of length, integrating the piece-wise linear segments it is made of.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.point_along_line">
<span class="sig-name descname"><span class="pre">point_along_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.point_along_line" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Cartesian coordinates of a point on the dislocation line. The location to be calculated must be specified in the form of a fractional position <em>t</em> along the continuous dislocation line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Normalized path coordinate in the range [0,1]</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The xyz coordinates of the requested point on the dislocation line.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.10.0.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">points</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.points" title="Permalink to this definition"></a></dt>
<dd><p>The sequence of spatial points that define the curved shape of this dislocation (in simulation coordinates). This is a <em>N</em> x 3 Numpy array, with <em>N&gt;2</em> being the number of points along the line.</p>
<p>For true dislocation loops, the first and the last point in the list coincide exactly. For infinite lines, the first and the last point coincide modulo a periodicity vector of the simulation domain.</p>
<p>The point sequence always forms a continuous line, which may lead outside the primary <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> if periodic boundary conditions (PBCs) are used, i.e., only the start of the dislocation is always inside the primary simulation cell but its end point may not. Thus, the line is stored in unwrapped form. A wrapping happens ad-hoc during visualization, when the <a class="reference internal" href="ovito_vis.html#ovito.vis.DislocationVis" title="ovito.vis.DislocationVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">DislocationVis</span></code></a> element renders the dislocation network or if the network is exported to a file format, e.g. VTK, which does not support PBCs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.spatial_burgers_vector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spatial_burgers_vector</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.spatial_burgers_vector" title="Permalink to this definition"></a></dt>
<dd><p>The Burgers vector of the segment, expressed in the global coordinate system of the simulation. This vector is calculated by transforming the true Burgers vector from the local lattice coordinate system to the global simulation coordinate system using the average orientation matrix of the crystal cluster the dislocation segment is embedded in.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.Line.true_burgers_vector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">true_burgers_vector</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.Line.true_burgers_vector" title="Permalink to this definition"></a></dt>
<dd><p>The Burgers vector of the dislocation expressed in the local coordinate system of the crystal the dislocation is located in. The true Burgers vectors of two dislocation lines may only be added if both belong to the same <a class="reference internal" href="#ovito.data.DislocationNetwork.Line.cluster_id" title="ovito.data.DislocationNetwork.Line.cluster_id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cluster_id</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.find_nodes">
<span class="sig-name descname"><span class="pre">find_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DislocationNetwork.find_nodes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of all unique dislocation nodes in the network.</p>
<p>For a detailed description of what a <em>node</em> is, see the <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connector</span></code></a> class. The list returned by this method contains one (arbitrary) <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector" title="ovito.data.DislocationNetwork.Connector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connector</span></code></a> from each network node, in no particular order. Each of these connectors serves as access into a node and can be used to visit the other connectors (dislocation arms) in the same node via <a class="reference internal" href="#ovito.data.DislocationNetwork.Connector.arms" title="ovito.data.DislocationNetwork.Connector.arms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connector.arms</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">network</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dislocations</span>

<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">network</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arm_count</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">arms</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">arm</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">true_burgers_vector</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.10.2.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.lines">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lines</span></span><a class="headerlink" href="#ovito.data.DislocationNetwork.lines" title="Permalink to this definition"></a></dt>
<dd><p>The list of dislocation lines in this dislocation network. This list-like object contains <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> objects in arbitrary order and is read-only.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.DislocationNetwork.set_line">
<span class="sig-name descname"><span class="pre">set_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_burgers_vector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.DislocationNetwork.set_line" title="Permalink to this definition"></a></dt>
<dd><p>This method can be used to manipulate certain aspects of a <a class="reference internal" href="#ovito.data.DislocationNetwork.Line" title="ovito.data.DislocationNetwork.Line"><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code></a> in the network. Fields for which no new value is specified will keep their current values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> – The zero-based index of the dislocation line to modify in the <a class="reference internal" href="#ovito.data.DislocationNetwork.lines" title="ovito.data.DislocationNetwork.lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lines</span></code></a> array.</p></li>
<li><p><strong>true_burgers_vector</strong> – The new lattice-space Burgers vector (<a class="reference internal" href="#ovito.data.DislocationNetwork.Line.true_burgers_vector" title="ovito.data.DislocationNetwork.Line.true_burgers_vector"><code class="xref py py-attr docutils literal notranslate"><span class="pre">true_burgers_vector</span></code></a>).</p></li>
<li><p><strong>cluster_id</strong> – The numeric ID of the crystallite cluster the dislocation line is embedded in (<a class="reference internal" href="#ovito.data.DislocationNetwork.Line.cluster_id" title="ovito.data.DislocationNetwork.Line.cluster_id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cluster_id</span></code></a>).</p></li>
<li><p><strong>points</strong> – An <span class="math notranslate nohighlight">\((N, 3)\)</span> NumPy array of Cartesian coordinates containing the dislocation’s vertices (<a class="reference internal" href="#ovito.data.DislocationNetwork.Line.points" title="ovito.data.DislocationNetwork.Line.points"><code class="xref py py-attr docutils literal notranslate"><span class="pre">points</span></code></a>).</p></li>
<li><p><strong>custom_color</strong> – RGB color to be used for rendering the line instead of the automatically determined color (<a class="reference internal" href="#ovito.data.DislocationNetwork.Line.custom_color" title="ovito.data.DislocationNetwork.Line.custom_color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">custom_color</span></code></a>).</p></li>
</ul>
</dd>
</dl>
<p>Example of a <a class="reference internal" href="../introduction/custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">user-defined modifier function</span></a> that manipulates the dislocation line data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DataCollection</span><span class="p">):</span>

    <span class="c1"># Flip Burgers vector and line sense of each dislocation:</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">lines</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">dislocations_</span><span class="o">.</span><span class="n">set_line</span><span class="p">(</span><span class="n">index</span><span class="p">,</span>
            <span class="n">true_burgers_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">true_burgers_vector</span><span class="p">),</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>

    <span class="c1"># Highlight all 1/6[121] dislocations by giving them a red color:</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dislocations</span><span class="o">.</span><span class="n">lines</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">true_burgers_vector</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="p">)):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">dislocations_</span><span class="o">.</span><span class="n">set_line</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">custom_color</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.ElementType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">ElementType</span></span><a class="headerlink" href="#ovito.data.ElementType" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>This class describes a single “type”, for example a particle or bond type, that is part of a <a class="reference internal" href="#typed-properties"><span class="std std-ref">typed property array</span></a>.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code> class is the generic base class used for all type descriptors in OVITO. It stores general attributes such as a type’s
unique numeric <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a>, its human-readable <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>, and its display <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">color</span></code></a>.
Note that, for certain <a class="reference internal" href="#typed-properties"><span class="std std-ref">typed properties</span></a>, OVITO uses more specific sub-classes such as <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> and <a class="reference internal" href="#ovito.data.BondType" title="ovito.data.BondType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondType</span></code></a>,
which can store additional attributes such as <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> and <a class="reference internal" href="#ovito.data.ParticleType.mass" title="ovito.data.ParticleType.mass"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mass</span></code></a>.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code> instances associated with a <a class="reference internal" href="#typed-properties"><span class="std std-ref">typed property</span></a> are found in the
<a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list.</p>
<p>You can use the <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Property.type_by_id()</span></code></a> and <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Property.type_by_name()</span></code></a>
methods to look up a certain <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code> based on a numeric identifier or name string.</p>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ElementType.color">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">color</span></span><a class="headerlink" href="#ovito.data.ElementType.color" title="Permalink to this definition"></a></dt>
<dd><p>The color used when rendering elements of this type. This is a RGB tuple with components in the range 0.0 – 1.0.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(1.0,</span> <span class="pre">1.0,</span> <span class="pre">1.0)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ElementType.enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enabled</span></span><a class="headerlink" href="#ovito.data.ElementType.enabled" title="Permalink to this definition"></a></dt>
<dd><p>Controls whether this type is currently <em>active</em> or <em>inactive</em>. This flag currently has a meaning only in the context of atomic structure identification. Some analysis modifiers manage a list of the structure types they can identify (e.g. FCC, BCC, etc.). The identification of individual structure types can be turned on or off by the user by changing their <code class="xref py py-attr docutils literal notranslate"><span class="pre">enabled</span></code> flag. See <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.StructureIdentificationModifier.structures" title="ovito.modifiers.StructureIdentificationModifier.structures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">StructureIdentificationModifier.structures</span></code></a> for further information.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ElementType.id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">id</span></span><a class="headerlink" href="#ovito.data.ElementType.id" title="Permalink to this definition"></a></dt>
<dd><p>The unique numeric identifier of the type (typically some positive <code class="docutils literal notranslate"><span class="pre">int</span></code>). The identifier is and must be unique among all element types in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list of a typed <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a>. Thus, if you create a new element type, make sure you give it a unique id before inserting it into the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list of a typed property.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ElementType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#ovito.data.ElementType.name" title="Permalink to this definition"></a></dt>
<dd><p>The name of this type, e.g. the chemical element symbol of an atom type. This string may be empty, in which case its numeric <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a> is the only way of referring to this type.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">''</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.Lines">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">Lines</span></span><a class="headerlink" href="#ovito.data.Lines" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.10.0.</span></p>
</div>
<p>The <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> class represents one or more 3D polylines. You can create an instance of this
class in a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> using the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.GenerateTrajectoryLinesModifier" title="ovito.modifiers.GenerateTrajectoryLinesModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateTrajectoryLinesModifier</span></code></a> or the
<a class="reference internal" href="#ovito.data.DataCollection.lines" title="ovito.data.DataCollection.lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.lines.create()</span></code></a> method.</p>
<p>You can retrieve existing <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> objects from a pipeline’s output through the
<a class="reference internal" href="#ovito.data.DataCollection.lines" title="ovito.data.DataCollection.lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.lines</span></code></a> dictionary view. Each <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object
has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> name that serves as a lookup key.</p>
<p><a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> objects are always associated with <a class="reference internal" href="ovito_vis.html#ovito.vis.LinesVis" title="ovito.vis.LinesVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinesVis</span></code></a> element, which controls the visual
appearance of the lines in rendered images. You can access the visual element through the <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a>
attribute provided by the <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a> base class. The <a class="reference internal" href="ovito_vis.html#ovito.vis.LinesVis" title="ovito.vis.LinesVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinesVis</span></code></a> element provides the capability to visualize
a local quantity defined at each line vertex using pseudo-color mapping.</p>
<p id="lines-property-list">The <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> container uses the following standard properties with predefined names and data layouts.
Additional per-vertex properties may be added using the <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a>
method of the base class.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property name</p></th>
<th class="head"><p>Python access</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Color</span></p></td>
<td></td>
<td><p>float32</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Position</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Lines.positions" title="ovito.data.Lines.positions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">positions</span></code></a></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Section</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Lines.sections" title="ovito.data.Lines.sections"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sections</span></code></a></p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Time</span></p></td>
<td><p><a class="reference internal" href="#ovito.data.Lines.time_stamps" title="ovito.data.Lines.time_stamps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">time_stamps</span></code></a></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Data model</strong></p>
<p>The <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> data object type is <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>, which means
it consist of a set of uniform property arrays. The standard property <span class="guilabel">Position</span> stores the
vertex coordinates. When rendering a <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object, consecutive vertices
get connected by linear line segments to form a <em>polyline</em> (which is also called a line “section”).
To denote the end of a contiguous polyline and the start of a new one, the property <span class="guilabel">Section</span> must be filled with <em>section identifiers</em>,
which mark consecutive sequences of vertices, each forming a separate polyline. Section identifiers are abitrary integer numbers
that stay the same within a polyline but change from one polyline to the next:</p>
<a class="reference internal image-reference" href="../_images/lines_example_definition.svg"><img alt="../_images/lines_example_definition.svg" class="align-right" src="../_images/lines_example_definition.svg" width="30%" /></a>
<table class="docutils align-center" id="id4" style="width: 60%">
<caption><span class="caption-text">Example: Definition of three polylines of length 2, 3, and 2, respectively.</span><a class="headerlink" href="#id4" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Vertex</p></th>
<th class="head"><p>Position</p></th>
<th class="head"><p>Section</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><span class="math notranslate nohighlight">\((x_0, y_0, z_0)\)</span></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><span class="math notranslate nohighlight">\((x_1, y_1, z_1)\)</span></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><span class="math notranslate nohighlight">\((x_2, y_2, z_2)\)</span></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><span class="math notranslate nohighlight">\((x_3, y_3, z_3)\)</span></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><span class="math notranslate nohighlight">\((x_4, y_4, z_4)\)</span></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p><span class="math notranslate nohighlight">\((x_5, y_5, z_5)\)</span></p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p><span class="math notranslate nohighlight">\((x_6, y_6, z_6)\)</span></p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p>The <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> class provides the <a class="reference internal" href="#ovito.data.Lines.create_line" title="ovito.data.Lines.create_line"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_line()</span></code></a> method to add new polylines to the container.
It appends a list of vertex coordinates to the <span class="guilabel">Position</span> property and automatically assigns a new unique
<span class="guilabel">Section</span> value to these vertices to define a new polyline.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In a <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> object created by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.GenerateTrajectoryLinesModifier" title="ovito.modifiers.GenerateTrajectoryLinesModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenerateTrajectoryLinesModifier</span></code></a>, the <span class="guilabel">Section</span> property
reflects the unique identifiers of the particles that traced the individual trajectory lines.</p>
</div>
<p>If the <span class="guilabel">Time</span> property is present, it stores the animation frame number at which each
vertex should appear in a trajectory animation. This feature allows to animate the lines over time
and is used for particle trajectory visualization. The gradual rendering of lines is only active if the
<a class="reference internal" href="ovito_vis.html#ovito.vis.LinesVis.upto_current_time" title="ovito.vis.LinesVis.upto_current_time"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LinesVis.upto_current_time</span></code></a> option is enabled in the attached visual element.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Lines.create_line">
<span class="sig-name descname"><span class="pre">create_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Lines.create_line" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new section (a <em>polyline</em>) to an existing <a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a> container. The container’s vertex <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a>
will be incremented by the number of newly inserted points. The method copies <em>positions</em> into the <code class="docutils literal notranslate"><span class="pre">Position</span></code> property array after extending the array
and gives the new polyline a unique <code class="docutils literal notranslate"><span class="pre">Section</span></code> property value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>positions</strong> (<em>array-like</em>) – The xyz coordinates for the new lines section (<em>N</em> x 3 array). <em>N</em> must be at least 2.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The unique section identifier that was assigned to the newly added polyline.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Lines.positions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positions</span></span><a class="headerlink" href="#ovito.data.Lines.positions" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> array containing the XYZ coordinates of the line vertices (<a class="reference internal" href="#lines-property-list"><span class="std std-ref">standard property</span></a> <span class="guilabel">Position</span>). May be <code class="docutils literal notranslate"><span class="pre">None</span></code> if the property is not defined yet. Use <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> to add the property to the container if necessary. Use <code class="xref py py-attr docutils literal notranslate"><span class="pre">positions_</span></code> (with an underscore) to access an independent copy of the array, whose contents can be safely modified in place.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Lines.sections">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sections</span></span><a class="headerlink" href="#ovito.data.Lines.sections" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> array with the section each line vertex belongs to (<a class="reference internal" href="#lines-property-list"><span class="std std-ref">standard property</span></a> <span class="guilabel">Section</span>). May be <code class="docutils literal notranslate"><span class="pre">None</span></code> if the property is not defined yet. Use <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> to add the property to the container if necessary. Use <code class="xref py py-attr docutils literal notranslate"><span class="pre">sections_</span></code> (with an underscore) to access an independent copy of the array, whose contents can be safely modified in place.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Lines.time_stamps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_stamps</span></span><a class="headerlink" href="#ovito.data.Lines.time_stamps" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> array with the time stamps of the line vertices (<a class="reference internal" href="#lines-property-list"><span class="std std-ref">standard property</span></a> <span class="guilabel">Time</span>). May be <code class="docutils literal notranslate"><span class="pre">None</span></code> if the property is not defined yet. Use <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> to add the property to the container if necessary. Use <code class="xref py py-attr docutils literal notranslate"><span class="pre">time_stamps_</span></code> (with an underscore) to access an independent copy of the array, whose contents can be safely modified in place.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.NearestNeighborFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">NearestNeighborFinder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_collection</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.NearestNeighborFinder" title="Permalink to this definition"></a></dt>
<dd><p>A utility class that finds the <em>N</em> nearest neighbors of a particle.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To find all neighbors within a spherical cutoff region around another particle, 
use <a class="reference internal" href="#ovito.data.CutoffNeighborFinder" title="ovito.data.CutoffNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">CutoffNeighborFinder</span></code></a> instead.</p>
</div>
<p>The constructor takes the requested number of nearest neighbors, <em>N</em>, and a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>
containing the input particles and the optional simulation cell.
<em>N</em> must be a positive integer not greater than 64, which is the built-in maximum of neighbors supported by this class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Keep in mind that, if the system contains only <em>N</em> particles or less, and if the simulation does not use periodic boundary conditions, then the 
neighbor finder will return less than the requested number of nearest neighbors.</p>
</div>
<p>Once the <code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code> has been initialized, you can call its <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find" title="ovito.data.NearestNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method to
iterate over the sorted list of nearest neighbors of a given central particle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up a neighbor finder for visiting the 12 closest neighbors of each particle.</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">NearestNeighborFinder</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># Loop over all input particles:</span>
<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nearest neighbors of particle </span><span class="si">%i</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
    <span class="c1"># Iterate over the neighbors of the current particle, starting with the closest:</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="c1"># The index can be used to access properties of the current neighbor, e.g.</span>
        <span class="n">type_of_neighbor</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span><span class="p">[</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>In addition, the class provides the <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find_at" title="ovito.data.NearestNeighborFinder.find_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_at()</span></code></a> method, which determines the <em>N</em> nearest particles around some
arbitrary spatial location:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visit particles closest to some spatial point (x,y,z):</span>
<span class="n">xyz_coords</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_at</span><span class="p">(</span><span class="n">xyz_coords</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.NearestNeighborFinder.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.NearestNeighborFinder.find" title="Permalink to this definition"></a></dt>
<dd><p>Returns an iterator that visits the <em>N</em> nearest neighbors of the given particle in order of ascending distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – The zero-based index of the central particle whose neighbors should be determined.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A Python iterator that visits the <em>N</em> nearest neighbors of the central particle in order of ascending distance.
For each neighbor being visited, the iterator returns an object having the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The global index of the current neighbor particle.</p></li>
<li><p><strong>distance</strong>: The distance of the current neighbor from the central particle.</p></li>
<li><p><strong>distance_squared</strong>: The squared neighbor distance.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector connecting the central particle with the current neighbor (correctly taking into account periodic boundary conditions).</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>The index can be used to look up properties of the neighbor particle, as demonstrated in the first example code above.</p>
<p>Note that several periodic images of the same particle may be visited if the periodic simulation cell is sufficiently small.
Then the same particle index will appear more than once in the neighbor list. In fact, the central particle may be among its own neighbors in a sufficiently small periodic simulation cell.
However, the computed neighbor vector (<cite>delta</cite>) will be unique for each image of a neighboring particle.</p>
<p>The number of neighbors actually visited may be smaller than the requested number, <em>N</em>, if the
system contains too few particles and is non-periodic.</p>
<p>Note that the <code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code> method will not find other particles located exactly at the same spatial position as the central particle for technical reasons.
To find such particles too, which are positioned exactly on top of each other, use <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find_at" title="ovito.data.NearestNeighborFinder.find_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_at()</span></code></a> instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.NearestNeighborFinder.find_all">
<span class="sig-name descname"><span class="pre">find_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.NearestNeighborFinder.find_all" title="Permalink to this definition"></a></dt>
<dd><p>Finds the <em>N</em> nearest neighbors of each particle in the system or of the subset of particles specified by <em>indices</em>. 
This is the batch-processing version of <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find" title="ovito.data.NearestNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>, allowing you to efficiently compute the neighbor lists and neighbor vectors of several 
particles at once, without explicit for-loop and by making use of all parallel processor cores.</p>
<p>The method returns two NumPy arrays:</p>
<p><code class="docutils literal notranslate"><span class="pre">neigh_idx</span></code> : NumPy array of shape (<em>M</em>, <em>N</em>) storing the indices of neighbor particles, 
with <em>M</em> equal to <em>len(indices)</em> or, if <em>indices</em> is <em>None</em>, the total number of particles in the system. 
<em>N</em> refers to the number of nearest neighbors requested in the <a class="reference internal" href="#ovito.data.NearestNeighborFinder" title="ovito.data.NearestNeighborFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborFinder</span></code></a> constructor. 
The computed indices in this array can be used to look up properties of neighbor particles in the global <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object.</p>
<p><code class="docutils literal notranslate"><span class="pre">neigh_vec</span></code> : NumPy array of shape (<em>M</em>, <em>N</em>, 3) storing the xyz components of the three-dimensional neighbor vectors (“delta”), 
which connect the <em>M</em> central particles with their <em>N</em> respective nearest neighbors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>indices</strong> – List of zero-based particle indices for which the neighbor lists should be computed. 
If left unspecified, neighbor lists will be computed for every particle in the system.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">(neigh_idx,</span> <span class="pre">neigh_vec)</span></code></p>
</dd>
</dl>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>To compute all pair-wise distances in one go, i.e. the 2-norms of the neighbor vectors, you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">distances</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">neigh_vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># Yields (M,N) array of neighbor distances</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.NearestNeighborFinder.find_at">
<span class="sig-name descname"><span class="pre">find_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.NearestNeighborFinder.find_at" title="Permalink to this definition"></a></dt>
<dd><p>Returns an iterator that visits the <em>N</em> nearest particles around a spatial point given by <em>coords</em> in order of ascending distance.
Unlike the <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find" title="ovito.data.NearestNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> method, which queries the nearest neighbors of a physical particle, <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_at()</span></code> allows
searching for nearby particles at arbitrary locations in space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coords</strong> – A coordinate triplet (x,y,z) specifying the spatial location where the <em>N</em> nearest particles should be queried.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A Python iterator that visits the <em>N</em> nearest neighbors in order of ascending distance.
For each visited particle the iterator returns an object with the following attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>index</strong>: The index of the current particle (starting at 0).</p></li>
<li><p><strong>distance</strong>: The distance of the current neighbor from the query location.</p></li>
<li><p><strong>distance_squared</strong>: The squared distance to the query location.</p></li>
<li><p><strong>delta</strong>: The three-dimensional vector from the query point to the current particle (correctly taking into account periodic boundary conditions).</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<p>If there is a particle located exactly at the query location <em>coords</em>, it will be among the returned neighbors.
This is in contrast to the <a class="reference internal" href="#ovito.data.NearestNeighborFinder.find" title="ovito.data.NearestNeighborFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> function, which skips the central particle itself.</p>
<p>The number of neighbors actually visited may be smaller than the requested number, <em>N</em>, if the
system contains too few particles and is non-periodic.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.ParticleType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">ParticleType</span></span><a class="headerlink" href="#ovito.data.ParticleType" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.ElementType</span></code></a></p>
<p>This data object describes one particle or atom type. In atomistic simulations, each chemical element is typically represented by an instance of
the <code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code> class. The attributes of this class control how the particles of that type get visualized in terms of e.g. color, particle radius, shape, etc.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code> class inherits several general attribute fields from its base class <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a>, e.g. the <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">color</span></code></a>, <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>
and <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a> fields. It adds specific fields for particles: <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> and <a class="reference internal" href="#ovito.data.ParticleType.shape" title="ovito.data.ParticleType.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a>. Furthermore, the class has additional
fields controlling the visual appearance of particles with user-defined shapes.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code> instances all live in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list of the <code class="docutils literal notranslate"><span class="pre">'Particle</span> <span class="pre">Type'</span></code> standard <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> array,
which is accessible as <a class="reference internal" href="#ovito.data.Particles.particle_types" title="ovito.data.Particles.particle_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Particles.particle_types</span></code></a>.
The association of particles with particle types is established through the unique type IDs.
The following code shows how to first list all unique particle types defined for a structure and then print the each particle’s type ID by iterating over the data array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Access the property with the name &#39;Particle Type&#39;:</span>
<span class="n">type_property</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span>

<span class="c1"># Print list of particle types (their numeric IDs and names)</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">type_property</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ID </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Print the numeric type ID of each particle:</span>
<span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">type_property</span><span class="p">[</span><span class="o">...</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
</pre></div>
</div>
<p>A common task is to look up the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> that corresponds to a given numeric type ID. For this, the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> class provides the <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_id()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Look up the particle type with unique ID 2:</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">type_property</span><span class="o">.</span><span class="n">type_by_id</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>

<span class="c1"># Iterate over all particles and print their type&#39;s name:</span>
<span class="k">for</span> <span class="n">tid</span> <span class="ow">in</span> <span class="n">type_property</span><span class="p">[</span><span class="o">...</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">type_property</span><span class="o">.</span><span class="n">type_by_id</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>Another common operation is to look up a particle type by name, for example the type representing a certain chemical element.
For this type of look-up the <a class="reference internal" href="#ovito.data.Property.type_by_name" title="ovito.data.Property.type_by_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_name()</span></code></a> method is available, which assumes that types have
unique <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">names</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">type_property</span><span class="o">.</span><span class="n">type_by_name</span><span class="p">(</span><span class="s1">&#39;Si&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>   <span class="c1"># Print numeric ID of type &#39;Si&#39;</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.backface_culling">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backface_culling</span></span><a class="headerlink" href="#ovito.data.ParticleType.backface_culling" title="Permalink to this definition"></a></dt>
<dd><p>Activates back-face culling for the user-defined particle shape mesh to speed up rendering. If turned on, polygonal sides of the shape mesh facing away from the viewer will not be rendered. You can turn this option off if the particle’s shape is not closed and two-sided rendering is required. This option only has an effect if a user-defined shape has been assigned to the particle type using the <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.highlight_edges">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">highlight_edges</span></span><a class="headerlink" href="#ovito.data.ParticleType.highlight_edges" title="Permalink to this definition"></a></dt>
<dd><p>Activates the highlighting of the polygonal edges of the user-defined particle shape during rendering. This option only has an effect if a user-defined shape has been assigned to the particle type using the <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.ParticleType.load_defaults">
<span class="sig-name descname"><span class="pre">load_defaults</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.ParticleType.load_defaults" title="Permalink to this definition"></a></dt>
<dd><p>Given the type’s chemical <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>, which must have been set before invoking this method, initializes the type’s <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">color</span></code></a>, <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a>, <a class="reference internal" href="#ovito.data.ParticleType.vdw_radius" title="ovito.data.ParticleType.vdw_radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vdw_radius</span></code></a> and , <a class="reference internal" href="#ovito.data.ParticleType.mass" title="ovito.data.ParticleType.mass"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mass</span></code></a> fields with default values from OVITO’s internal database of chemical elements.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ovito.data.Property.add_type_name" title="ovito.data.Property.add_type_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Property.add_type_name()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.ParticleType.load_shape">
<span class="sig-name descname"><span class="pre">load_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><span class="pre">str</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.ParticleType.load_shape" title="Permalink to this definition"></a></dt>
<dd><p>Assigns a user-defined shape to the particle type. Particles of this type will subsequently be rendered using the polyhedral :py:<a class="reference internal" href="#ovito.data.ParticleType.mesh" title="ovito.data.ParticleType.mesh"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mesh</span></code></a> loaded from the given file. The method will automatically detect the format of the geometry file and supports standard file formats such as OBJ, STL and VTK that contain triangle meshes, see <a class="reference external" href="../../reference/file_formats/file_formats_input.html#file-formats-input" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">this table</span></a>.</p>
<p>The shape loaded from the geometry file will be scaled with the <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> value set for this particle type or the per-particle value stored in the <code class="docutils literal notranslate"><span class="pre">Radius</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a> if present. The shape of each particle will be rendered such that its origin is located at the coordinates of the particle (<code class="docutils literal notranslate"><span class="pre">Position</span></code> property).</p>
<p>The following example script demonstrates how to load a user-defined shape for the first particle type (index 0) loaded from a LAMMPS dump file, which can be accessed through the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list of the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_scene</span><span class="p">()</span>

<span class="n">types</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span>
<span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">load_shape</span><span class="p">(</span><span class="s2">&quot;input/tetrahedron.vtk&quot;</span><span class="p">)</span>
<span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">highlight_edges</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.mass">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mass</span></span><a class="headerlink" href="#ovito.data.ParticleType.mass" title="Permalink to this definition"></a></dt>
<dd><p>The mass of this particle type.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0.0</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.mesh">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mesh</span></span><a class="headerlink" href="#ovito.data.ParticleType.mesh" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> object to be used as custom shape for rendering particles of this type. You can either programmatically create a <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> from a list of vertices and faces and assign it to this field, or let the <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method read the shape mesh from a separate geometry file. Also some <a class="reference external" href="../../reference/file_formats/file_formats_input.html#file-formats-input" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">file readers</span></a> (e.g. GSD and Aspherix) may generate the shape mesh automatically based on information found in the simulation file.</p>
<p>The <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis" title="ovito.vis.ParticlesVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticlesVis</span></code></a> element, which is responsible for visualizing a particle system, will render an instance of the mesh at each particle site, uniformely scaled by the particle’s <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a>, translated by the coordinates taken from the <code class="docutils literal notranslate"><span class="pre">Position</span></code> particle property, and rotated by the quaternion transformation taken from the <code class="docutils literal notranslate"><span class="pre">Orientation</span></code> particle property.</p>
<p>Note: This mesh will be ignored by the <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis" title="ovito.vis.ParticlesVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticlesVis</span></code></a> element unless the type’s <a class="reference internal" href="#ovito.data.ParticleType.shape" title="ovito.data.ParticleType.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Mesh</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.8.0.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.radius">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">radius</span></span><a class="headerlink" href="#ovito.data.ParticleType.radius" title="Permalink to this definition"></a></dt>
<dd><p>This attribute controls the display radius of all particles of this type.</p>
<p>When set to zero, particles of this type will be rendered using the standard size specified by the <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis.radius" title="ovito.vis.ParticlesVis.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticlesVis.radius</span></code></a> parameter. Furthermore, precedence is given to any per-particle sizes assigned to the <code class="docutils literal notranslate"><span class="pre">Radius</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a> if that property has been defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0.0</span></code></p>
</dd>
</dl>
<p>The following example script demonstrates how to set the display radii of two particle types loaded from a simulation file, which can be accessed through the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Property.types</span></code></a> list of the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_scene</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">setup_particle_types</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Cu&quot;</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.35</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Zr&quot;</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.55</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setup_particle_types</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#ovito.data.ParticleType.shape" title="Permalink to this definition"></a></dt>
<dd><p>Selects the geometric shape used when rendering particles of this type. Supported modes are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Unspecified</span></code> (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Sphere</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Box</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Circle</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Square</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Cylinder</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Spherocylinder</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParticlesVis.Shape.Mesh</span></code></p></li>
</ul>
</div></blockquote>
<p>By default, the standard particle shape that is set in the <a class="reference internal" href="ovito_vis.html#ovito.vis.ParticlesVis.shape" title="ovito.vis.ParticlesVis.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticlesVis</span></code></a> visual element is used to render particles of this type. Parameter values other than <code class="docutils literal notranslate"><span class="pre">Unspecified</span></code> allow you to control the rendering shape on a per-type basis. Mode <code class="docutils literal notranslate"><span class="pre">Sphere</span></code> includes ellipsoid and superquadric particle shapes, which are enabled by the presence of the <code class="docutils literal notranslate"><span class="pre">Aspherical</span> <span class="pre">Shape</span></code> and <code class="docutils literal notranslate"><span class="pre">Superquadric</span> <span class="pre">Roundness</span></code> <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle properties</span></a>.</p>
<p>The <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method lets you specify a user-defined <a class="reference internal" href="#ovito.data.ParticleType.mesh" title="ovito.data.ParticleType.mesh"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mesh</span></code></a> geometry for this particle type. Calling this method automatically switches the shape parameter to mode <code class="docutils literal notranslate"><span class="pre">Mesh</span></code>.</p>
<p>Setting the shapes of particle types permanently, i.e., for all frames of a loaded simulation trajectory, typically requires a user-defined modifier function. This function is inserted into the <a class="reference internal" href="ovito_pipeline.html#ovito.pipeline.Pipeline" title="ovito.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> to make the necessary changes to the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> objects associated with the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> named <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="kn">import</span> <span class="n">import_file</span>
<span class="kn">from</span> <span class="nn">ovito.vis</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Load a simulation file containing numeric particle types 1, 2, 3, ...</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/nylon.data&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_scene</span><span class="p">()</span>

<span class="c1"># Set the default particle shape in the ParticlesVis visual element, </span>
<span class="c1"># which will be used by all particle types for which we do not specify a different shape below.</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ParticlesVis</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">Box</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1"># A user-defined modifier function that configures the shapes of particle types 1 and 2:</span>
<span class="k">def</span> <span class="nf">setup_particle_types</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span> 
    <span class="c1"># Write access to property &#39;Particle Type&#39;:</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span>  
    <span class="c1"># Write access to numeric ParticleTypes, which are sub-objects of the Property object:</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ParticlesVis</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">Cylinder</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.2</span>
    <span class="n">types</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ParticlesVis</span><span class="o">.</span><span class="n">Shape</span><span class="o">.</span><span class="n">Sphere</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setup_particle_types</span><span class="p">)</span>

<span class="c1"># Render a picture of the 3d scene:</span>
<span class="n">vp</span> <span class="o">=</span> <span class="n">Viewport</span><span class="p">(</span><span class="n">camera_dir</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">vp</span><span class="o">.</span><span class="n">zoom_all</span><span class="p">()</span>
<span class="n">vp</span><span class="o">.</span><span class="n">render_image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;output/particles.png&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span> <span class="n">renderer</span><span class="o">=</span><span class="n">TachyonRenderer</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.use_mesh_color">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">use_mesh_color</span></span><a class="headerlink" href="#ovito.data.ParticleType.use_mesh_color" title="Permalink to this definition"></a></dt>
<dd><p>Use the intrinsic mesh color(s) instead of the particle color when rendering particles of this type. This option only has an effect if a user-defined shape :py:<a class="reference internal" href="#ovito.data.ParticleType.mesh" title="ovito.data.ParticleType.mesh"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mesh</span></code></a> has been assigned to this particle type, e.g., by calling the <a class="reference internal" href="#ovito.data.ParticleType.load_shape" title="ovito.data.ParticleType.load_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_shape()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.ParticleType.vdw_radius">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vdw_radius</span></span><a class="headerlink" href="#ovito.data.ParticleType.vdw_radius" title="Permalink to this definition"></a></dt>
<dd><p>The van der Waals radius of the particle type. This value is used by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CreateBondsModifier" title="ovito.modifiers.CreateBondsModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateBondsModifier</span></code></a> to decide which pairs of particles are close enough to be connected by a bond. In contrast to the <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> parameter, the van der Waals radius does not affect the visual appearance of the particles of this type.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">0.0</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.Particles">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">Particles</span></span><a class="headerlink" href="#ovito.data.Particles" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
<p>This object stores a system of particles and their properties. Additional things which
are typically associated with molecular systems, e.g. <a class="reference internal" href="#ovito.data.Particles.bonds" title="ovito.data.Particles.bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bonds</span></code></a>, <a class="reference internal" href="#ovito.data.Particles.angles" title="ovito.data.Particles.angles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">angles</span></code></a>, etc. are stored
in corresponding sub-objects.</p>
<p>A <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> object is usually part of a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a> where it can
be found via the <a class="reference internal" href="#ovito.data.DataCollection.particles" title="ovito.data.DataCollection.particles"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.particles</span></code></a> property.</p>
<p>The total number of particles is specified by the <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> attribute, which
the <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> class inherits from its <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class.</p>
<p>Particles are usually associated with a set of properties, e.g. position, type, velocity. Each of the properties is represented by a
separate <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data object, which is basically an array of numeric values, one for each particle in the system.
A particle property is identified by its unique name and can be looked up via the dictionary interface of the
<a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> base class. OVITO predefines a set of <em>standard properties</em>,
which have a fixed data layout, meaning, and role:</p>
<table class="docutils align-default" id="particle-properties-list">
<thead>
<tr class="row-odd"><th class="head"><p>Standard property name</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Angular Momentum</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Angular Velocity</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Aspherical Shape</span></p></td>
<td><p>float32</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Centrosymmetry</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Charge</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Cluster</span></p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Color</span></p></td>
<td><p>float32</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Coordination</span></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Deformation Gradient</span></p></td>
<td><p>float64</p></td>
<td><p>XX, YX, ZX, XY, YY, ZY, XZ, YZ, ZZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Dipole Magnitude</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Dipole Orientation</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Displacement Magnitude</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Displacement</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">DNA Strand</span></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Elastic Deformation Gradient</span></p></td>
<td><p>float64</p></td>
<td><p>XX, YX, ZX, XY, YY, ZY, XZ, YZ, ZZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Elastic Strain</span></p></td>
<td><p>float64</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Force</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Kinetic Energy</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Mass</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Molecule Identifier</span></p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Molecule Type</span></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Nucleobase</span></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Nucleotide Axis</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Nucleotide Normal</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Orientation</span></p></td>
<td><p>float32</p></td>
<td><p>X, Y, Z, W</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Particle Identifier</span></p></td>
<td><p>int64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Particle Type</span></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Periodic Image</span></p></td>
<td><p>int32</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Position</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Potential Energy</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Radius</span></p></td>
<td><p>float32</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Rotation</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z, W</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Selection</span></p></td>
<td><p>int8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Spin</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Strain Tensor</span></p></td>
<td><p>float64</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Stress Tensor</span></p></td>
<td><p>float64</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Stretch Tensor</span></p></td>
<td><p>float64</p></td>
<td><p>XX, YY, ZZ, XY, XZ, YZ</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Structure Type</span></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Superquadric Roundness</span></p></td>
<td><p>float32</p></td>
<td><p>Phi, Theta</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Torque</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Total Energy</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Transparency</span></p></td>
<td><p>float32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Vector Color</span></p></td>
<td><p>float32</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Velocity Magnitude</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Velocity</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
</tbody>
</table>
<p>For some of the most important properties, this container class provides quick access getters such as <a class="reference internal" href="#ovito.data.Particles.positions" title="ovito.data.Particles.positions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">positions</span></code></a>,
<a class="reference internal" href="#ovito.data.Particles.identifiers" title="ovito.data.Particles.identifiers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifiers</span></code></a>, or <a class="reference internal" href="#ovito.data.Particles.particle_types" title="ovito.data.Particles.particle_types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">particle_types</span></code></a> to look them up:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span>
</pre></div>
</div>
<p>User-defined particle properties having non-standard names, and standard properties for which no quick access getter exists, can be looked up
by literal name:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mol_ids</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Molecule Identifier&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>For more information on how to add or modify particle properties, please see the <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>
and <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> classes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Particles.add_particle">
<span class="sig-name descname"><span class="pre">add_particle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">position</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Particles.add_particle" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new particle to the model. The particle <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> will be incremented by one.
The method assigns <em>position</em> to the <code class="docutils literal notranslate"><span class="pre">Position</span></code> property of the new particle. The values of all other properties
are initialized to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>position</strong> (<em>array-like</em>) – The xyz coordinates for the new particle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The index of the newly created particle, i.e. <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">(Particles.count-1)</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.angles">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">angles</span></span><a class="headerlink" href="#ovito.data.Particles.angles" title="Permalink to this definition"></a></dt>
<dd><p>A <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the list of angles defined for the molecular model (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.bonds">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bonds</span></span><a class="headerlink" href="#ovito.data.Particles.bonds" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> data object storing the list of bonds and their properties (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.colors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">colors</span></span><a class="headerlink" href="#ovito.data.Particles.colors" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Color</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Particles.create_bonds">
<span class="sig-name descname"><span class="pre">create_bonds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vis_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Particles.create_bonds" title="Permalink to this definition"></a></dt>
<dd><p>This convenience method conditionally creates and associates a <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object with this <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> parent object.
If there is already an existing bonds object (<a class="reference internal" href="#ovito.data.Particles.bonds" title="ovito.data.Particles.bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bonds</span></code></a> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>), then that bonds object is
replaced with a <a class="reference internal" href="../introduction/data_manipulation.html#data-ownership"><span class="std std-ref">modifiable copy</span></a> if necessary. The attached <a class="reference internal" href="ovito_vis.html#ovito.vis.BondsVis" title="ovito.vis.BondsVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsVis</span></code></a> element is preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Key/value pairs passed to the method as keyword arguments are used to set attributes of the <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a> object (even if the bonds object already existed).</p></li>
<li><p><strong>vis_params</strong> (<em>Mapping</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><em>Any</em><em>]</em>) – Optional dictionary to initialize attributes of the attached <a class="reference internal" href="ovito_vis.html#ovito.vis.BondsVis" title="ovito.vis.BondsVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondsVis</span></code></a> element (only used if the bonds object is newly created by the method).</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds">ovito.data.Bonds</a></p>
</dd>
</dl>
<p>The logic of this method is roughly equivalent to the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_bonds</span><span class="p">(</span><span class="n">particles</span><span class="p">:</span> <span class="n">Particles</span><span class="p">,</span> <span class="n">vis_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bonds</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">particles</span><span class="o">.</span><span class="n">bonds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">particles</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">Bonds</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vis_params</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">vis_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">particles</span><span class="o">.</span><span class="n">bonds_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">particles</span><span class="o">.</span><span class="n">bonds_</span>
</pre></div>
</div>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="c1"># Pairs of particle indices to connect by bonds</span>
<span class="n">bonds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_bonds</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">),</span> <span class="n">vis_params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">})</span>
<span class="n">bonds</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Topology&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">pairs</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Particles.delta_vector">
<span class="sig-name descname"><span class="pre">delta_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_pbcvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Particles.delta_vector" title="Permalink to this definition"></a></dt>
<dd><p>Computes the vector connecting two particles <em>a</em> and <em>b</em> in a periodic simulation cell by applying the minimum image convention.</p>
<p>This is a convenience wrapper for the <a class="reference internal" href="#ovito.data.SimulationCell.delta_vector" title="ovito.data.SimulationCell.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SimulationCell.delta_vector()</span></code></a> method,
which computes the vector between two arbitrary spatial locations <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span> taking into account periodic
boundary conditions. The version of the method described here takes two particle indices <em>a</em> and <em>b</em> as input, computing the shortest vector
<span class="math notranslate nohighlight">\({\Delta} = (r_b - r_a)\)</span> between them using the <a class="reference external" href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">minimum image convention</a>.
Please see the <a class="reference internal" href="#ovito.data.SimulationCell.delta_vector" title="ovito.data.SimulationCell.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SimulationCell.delta_vector()</span></code></a> method for further information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Zero-based index of the first input particle. This may also be an array of particle indices.</p></li>
<li><p><strong>b</strong> – Zero-based index of the second input particle. This may also be an array of particle indices with the same length as <em>a</em>.</p></li>
<li><p><strong>cell</strong> (<a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><em>SimulationCell</em></a>) – The periodic domain. Typically, <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.cell</span></code></a> is used as argument here.</p></li>
<li><p><strong>return_pbcvec</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a>) – If True, also returns the vector <span class="math notranslate nohighlight">\(n\)</span>, which specifies how often the computed particle-to-particle vector crosses the cell’s face.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The delta vector and, optionally, the vector <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.dihedrals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dihedrals</span></span><a class="headerlink" href="#ovito.data.Particles.dihedrals" title="Permalink to this definition"></a></dt>
<dd><p>A <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the list of dihedrals defined for the molecular model (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.forces">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forces</span></span><a class="headerlink" href="#ovito.data.Particles.forces" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Force</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.identifiers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identifiers</span></span><a class="headerlink" href="#ovito.data.Particles.identifiers" title="Permalink to this definition"></a></dt>
<dd><p>Returns a <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array containing the values of the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Identifier</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that particle property does not exist.</p>
<p>The property array stores the numerical IDs that are typically used by simulation codes to uniquely identify individual particles.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A particle <em>identifier</em> is an arbitrary and unique 64-bit integer value permanently associated with a particle. In contrast, the particle’s <em>index</em> is implicitly
given by the particle’s current position within the particles list.</p>
<p>If you delete some of the particles from the system, using the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.DeleteSelectedModifier" title="ovito.modifiers.DeleteSelectedModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeleteSelectedModifier</span></code></a> or the <a class="reference internal" href="#ovito.data.PropertyContainer.delete_elements" title="ovito.data.PropertyContainer.delete_elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete_elements()</span></code></a> method for example,
the indices of the remaining particles get typically shifted but their unique IDs stay the same.</p>
</div>
<p>Some of OVITO’s <a class="reference external" href="../../reference/file_formats/file_formats_input.html#file-formats-input" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">simulation file readers</span></a> provide the option to sort the list of particles by ID during
import to obtain a stable ordering. Generally, however, the storage order of particles is arbitrary and can vary between frames
of a trajectory. The <a class="reference internal" href="#ovito.data.Particles.remap_indices" title="ovito.data.Particles.remap_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remap_indices()</span></code></a> method can be useful in this situation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <a class="reference internal" href="#ovito.data.Particles.identifiers" title="ovito.data.Particles.identifiers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifiers</span></code></a> may be <code class="docutils literal notranslate"><span class="pre">None</span></code>, which means particles don’t have any identifiers. Many operations in OVITO then assume that the ordering
and total count of particles are constant throughout the entire simulation trajectory and the identities are implicitly given by the particles’ <em>indices</em>.</p>
</div>
<p>Given some list of zero-based particle <em>indices</em>, determining the corresponding unique identifiers requires just a simple <a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html#basics-indexing" title="(in NumPy v1.26)"><span class="xref std std-ref">NumPy indexing</span></a> expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># &lt;-- zero-based particle indices for which we want to look up IDs</span>
<span class="n">ids</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span><span class="p">[</span><span class="n">query_indices</span><span class="p">]</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_indices</span><span class="p">)</span>
</pre></div>
</div>
<p>The reverse lookup, i.e., finding the indices at which particles with certain IDs are stored in the list, requires some more work.
That’s because particles may be stored in arbitrary order, i.e., the sequence of unique IDs is generally not sorted nor contigous.
A rather <strong>slow</strong> approach is to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.argwhere.html#numpy.argwhere" title="(in NumPy v1.26)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">search</span></code></a> through the entire array of IDs to locate the one we are looking for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query_id</span> <span class="o">=</span> <span class="mi">37</span> <span class="c1"># &lt;-- a unique particle ID we are looking for</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span> <span class="o">==</span> <span class="n">query_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">query_id</span>
</pre></div>
</div>
<p>We can speed things up with some extra effort, which pays off when there is a need to look up several particle IDs.
To this end, we first <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.argsort.html#numpy.argsort" title="(in NumPy v1.26)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a> the list of IDs, then perform a more efficient <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.searchsorted.html#numpy.searchsorted" title="(in NumPy v1.26)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sorted</span> <span class="pre">search</span></code></a>,
and finally map the found indices back to the original particle ordering:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># &lt;-- some unique particle IDs we want to look up all at once</span>
<span class="n">ordering</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span><span class="p">)</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">ordering</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span><span class="p">,</span> <span class="n">query_ids</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">ordering</span><span class="p">)]</span>
<span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">query_ids</span><span class="p">)</span>
</pre></div>
</div>
<p>The above <code class="docutils literal notranslate"><span class="pre">assert</span></code> statements are for illustration purposes only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.impropers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">impropers</span></span><a class="headerlink" href="#ovito.data.Particles.impropers" title="Permalink to this definition"></a></dt>
<dd><p>A <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the list of impropers defined for the molecular model (may be <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.masses">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">masses</span></span><a class="headerlink" href="#ovito.data.Particles.masses" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Mass</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.orientations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">orientations</span></span><a class="headerlink" href="#ovito.data.Particles.orientations" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Orientation</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.particle_types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">particle_types</span></span><a class="headerlink" href="#ovito.data.Particles.particle_types" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Type</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.positions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positions</span></span><a class="headerlink" href="#ovito.data.Particles.positions" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array storing the particle coordinates, i.e. the values of the <code class="docutils literal notranslate"><span class="pre">Position</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>.
Accessing this field is equivalent to a name-based lookup in the <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span> <span class="ow">is</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;Position&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Under special circumstances the <code class="docutils literal notranslate"><span class="pre">Position</span></code> particle property might not be defined (yet). Then the value is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> will likely be write-protected. If you intend to modify (some of) the particle coordinates in the property array,
request a modifiable version of the array by using the <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">underscore notation</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">positions_</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_coordinates</span>
</pre></div>
</div>
<p>Alternatively, you can use the <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> method to newly create or overwrite the entire property:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Position&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">new_coordinates</span><span class="p">)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Particles.remap_indices">
<span class="sig-name descname"><span class="pre">remap_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">particles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><span class="pre">Particles</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.26)"><span class="pre">numpy.ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#slice" title="(in Python v3.12)"><span class="pre">slice</span></a></span></span><a class="headerlink" href="#ovito.data.Particles.remap_indices" title="Permalink to this definition"></a></dt>
<dd><p>In case the storage order of atoms or particles changes during the course of a simulation, this method can determine the mapping of particles from one snapshot of the trajectory to another. It uses the unique <a class="reference internal" href="#ovito.data.Particles.identifiers" title="ovito.data.Particles.identifiers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifiers</span></code></a> of the particles to do that.</p>
<p>Given two data collections <em>A</em> and <em>B</em> containing the same set of particles but in different order, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remap_indices()</span></code> determines for each particle in <em>B</em> the zero-based index at which the same particle is found in <em>A</em>. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="go">[8 101  5 30 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">identifiers</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="go">[5 101 30 99  8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">remap_indices</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">particles</span><span class="p">)</span>
<span class="go">[2 1 3 4 0]</span>
</pre></div>
</div>
<p>The index mapping generated by <code class="xref py py-meth docutils literal notranslate"><span class="pre">remap_indices()</span></code> allows you to retrieve property values of particles in <em>A</em> in the same order in which they appear in <em>B</em>, making it easy to perform computations involving property values at different trajectory timesteps, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mapping</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">remap_indices</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">particles</span><span class="p">)</span>
<span class="n">displacements</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">mapping</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">remap_indices()</span></code> compares the unique <a class="reference internal" href="#ovito.data.Particles.identifiers" title="ovito.data.Particles.identifiers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifiers</span></code></a> stored in the <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">Identifier</span></code> property arrays of both snapshots to compute the index permutation map. If this property is not defined, which may be the case if the imported trajectory file did not contain atom IDs, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">remap_indices()</span></code> method simply assumes that both snapshots use the same constant storage order and returns the identity mapping - as a Python <a class="reference external" href="https://docs.python.org/3/library/functions.html#slice" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> object for optimal performance when being used for <a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html#basics-indexing" title="(in NumPy v1.26)"><span class="xref std std-ref">NumPy indexing</span></a>. A slice object is also returned in case the ordering of particle IDs turns out to be the same in both snapshots and no remapping is necessary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An error will be raised if particles with duplicate IDs occur in snapshot <em>A</em> - 
but it is okay if <em>B</em> contains duplicate IDs. Furthermore, it is <em>not</em> an error if <em>A</em> contains additional particles that are not present 
in <em>B</em> - as long as all particles from <em>B</em> are found in <em>A</em>.</p>
</div>
<p>The default behavior of the method is to look up all particles of <em>B</em> in <em>A</em>. But the index mapping can also be established just for a subset of particles from <em>B</em> by supplying the optional parameter <em>indices</em>. The method expects an array of zero-based indices specifying which particles from snapshot <em>B</em> should be looked up in snapshot <em>A</em>. The returned mapping will have the same length as <em>indices</em>. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># The numeric ID of atom type &#39;H&#39;:</span>
<span class="n">hydrogen_type</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span><span class="o">.</span><span class="n">type_by_name</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">id</span>
<span class="c1"># Determine the indices of all H atoms in data collection B:</span>
<span class="n">hydrogen_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span> <span class="o">==</span> <span class="n">hydrogen_type</span><span class="p">)</span>

<span class="c1"># Determine the corresponding indices of the same atoms in data collection A:</span>
<span class="n">mapping</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">remap_indices</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="n">hydrogen_indices</span><span class="p">)</span>

<span class="c1"># In snapshot A the same particles are all H atoms too:</span>
<span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span><span class="p">[</span><span class="n">mapping</span><span class="p">]</span> <span class="o">==</span> <span class="n">hydrogen_type</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.5.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.selection">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">selection</span></span><a class="headerlink" href="#ovito.data.Particles.selection" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Selection</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.structure_types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">structure_types</span></span><a class="headerlink" href="#ovito.data.Particles.structure_types" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Structure</span> <span class="pre">Type</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Particles.velocities">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">velocities</span></span><a class="headerlink" href="#ovito.data.Particles.velocities" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> data array for the <code class="docutils literal notranslate"><span class="pre">Velocity</span></code> standard <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">particle property</span></a>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if that property is undefined.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.Property">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">Property</span></span><a class="headerlink" href="#ovito.data.Property" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>A storage array for the values of one uniform property of particles, bonds, voxel grid cells, etc.
For example, the “<em>Position</em>” property of particles is represented by one <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> object storing
the xyz cordinates of all the particles.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> objects are always managed by a specific sub-type of the <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> class, for example
<a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a>, <a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a>, <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a>, or <a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a>. These container classes
allow to add and remove properties to the data elements they represent. The properties within the <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> are accessed by name.
Here, for example, the particle property holding the particle coordinates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>This <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> object behaves almost like a regular NumPy array. For example, you can access the value for the <em>i</em>-th element using array indexing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;XYZ coordinates of first particle:&#39;</span><span class="p">,</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;z-coordinate of sixth particle:&#39;</span><span class="p">,</span> <span class="n">positions</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>   <span class="c1"># --&gt; (data.particles.count, 3)</span>
</pre></div>
</div>
<p>Since the “<em>Position</em>” <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">standard property has three components</span></a>, this <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> object is an array of shape (<em>N</em>,3).
Properties can be either vectorial or scalar, and they can hold uniform data types <code class="docutils literal notranslate"><span class="pre">float64</span></code>, <code class="docutils literal notranslate"><span class="pre">float32</span></code>, <code class="docutils literal notranslate"><span class="pre">int8</span></code>, <code class="docutils literal notranslate"><span class="pre">int32</span></code> or <code class="docutils literal notranslate"><span class="pre">int64</span></code>.</p>
<p>If you want to set or modify the values stored in a property array, make sure you are working with a modifiable version of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> object
by employing the <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">underscore notation</span></a>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modifiable_positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="p">[</span><span class="s1">&#39;Position_&#39;</span><span class="p">]</span>
<span class="n">modifiable_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric" id="typed-properties">Typed properties</p>
<p>In OVITO, the <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">standard particle property</span></a> “<em>Particle Type</em>” contains the <a class="reference external" href="../../reference/pipelines/data_objects/particles.html#scene-objects-particle-types" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">types of particles encoded as integer values</span></a>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_property</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Particle Type&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">type_property</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>
<span class="go">[2 1 3 ..., 2 1 2]</span>
</pre></div>
</div>
<p>The property array stores numeric <em>type identifiers</em> denoting each particle’s chemical type (e.g. 1=Cu, 2=Ni, 3=Fe, etc.).
The mapping of unique numeric IDs to human-readable type <em>names</em> is found in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list, which is
attached to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> array, making it a so-called <em>typed property</em>. This list contains one <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> descriptor per unique numerical type,
specifying its human-readable <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> as well as other attributes such as display <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">color</span></code></a>,
<a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">radius</span></code></a> and <a class="reference internal" href="#ovito.data.ParticleType.mass" title="ovito.data.ParticleType.mass"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mass</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">type_property</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 Cu [0.188 0.313 0.972] 0.74</span>
<span class="go">2 Ni [0.564 0.564 0.564] 0.77</span>
<span class="go">3 Fe [1 0.050 0.050] 0.74</span>
</pre></div>
</div>
<p>Numeric type IDs typically start at 1 and form a consecutive sequence as in the example above. But they don’t have to.
The descriptors may be listed in any order and their numeric IDs may be arbitrary integers.
Thus, in general, it is not valid to directly use a numeric type ID as an index into the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.
Instead, the <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_id()</span></code></a> method should be used to look up the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> descriptor for a given numeric ID:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">type_property</span><span class="p">):</span> <span class="c1"># loop over the type IDs of particles</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Atom </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> is of type </span><span class="si">{</span><span class="n">type_property</span><span class="o">.</span><span class="n">type_by_id</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Atom 0 is of type Ni</span>
<span class="go">Atom 1 is of type Cu</span>
<span class="go">Atom 2 is of type Fe</span>
<span class="go">Atom 3 is of type Cu</span>
</pre></div>
</div>
<p>Similarly, a <a class="reference internal" href="#ovito.data.Property.type_by_name" title="ovito.data.Property.type_by_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_name()</span></code></a> method exists that allows to look up a <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticleType</span></code></a> from the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list by name.
For example, to count the number of Fe atoms in a system, we first need to determine the numeric ID of the type “Fe” and then count the
number of occurences of the value in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code> array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Fe_type_id</span> <span class="o">=</span> <span class="n">type_property</span><span class="o">.</span><span class="n">type_by_name</span><span class="p">(</span><span class="s1">&#39;Fe&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">id</span>  <span class="c1"># Determine numeric ID of the &#39;Fe&#39; type.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">type_property</span> <span class="o">==</span> <span class="n">Fe_type_id</span><span class="p">)</span>  <span class="c1"># Count particles having that type ID.</span>
<span class="go">957</span>
</pre></div>
</div>
<p>Note that the data model supports multiple type classifications per particle. For example, while the “<em>Particle Type</em>” <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">standard particle property</span></a>,
stores the chemical types of atoms (e.g. C, H, Fe, …), the “<em>Structure Type</em>” property stores the structural lattice types computed for each atom
(e.g. FCC, BCC, …). In other words, multiple <em>typed properties</em> can co-exist to define several orthogonal classifications, and each typed property maintains its separate list
of type descriptors in the associated <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.</p>
<p>New types can be added to a typed property either using <a class="reference internal" href="#ovito.data.Property.add_type_id" title="ovito.data.Property.add_type_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_id()</span></code></a> or <a class="reference internal" href="#ovito.data.Property.add_type_name" title="ovito.data.Property.add_type_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_name()</span></code></a>. Use the former method if it is important that
the new type gets a particular numeric ID (which must not collide with existing types in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list). Use the latter method if
you don’t care about the numeric ID and let the method automatically assign a unique ID to the new type.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="../../reference/pipelines/data_objects/particles.html#scene-objects-particle-types" title="(in OVITO User Manual v3.10.4)"><span>Typed properties</span></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Property.add_type_id">
<span class="sig-name descname"><span class="pre">add_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">container</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><span class="pre">PropertyContainer</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><span class="pre">ElementType</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><span class="pre">ParticleType</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#ovito.data.BondType" title="ovito.data.BondType"><span class="pre">BondType</span></a></span></span><a class="headerlink" href="#ovito.data.Property.add_type_id" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new numeric <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> with the given numeric <em>id</em> and an optional human-readable <em>name</em> and adds it to this property’s <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list. If the list already contains an existing element type with the same numeric id, that existing type will be returned (without updating its name).</p>
<p>Additionally, you must specify the <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> containing this property object as second parameter, because it determines the kind of <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> to create. For example, when calling <a class="reference internal" href="#ovito.data.Property.add_type_id" title="ovito.data.Property.add_type_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_id()</span></code></a> on the property “<cite>Particle Type</cite>” of a <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> container, this method will create a new <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> object – a specific sub-class of the more general <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> class. Furthermore, if <em>name</em> matches one of the standard type names predefined for that particle property, e.g., a chemical symbol in case of the “<cite>Particle Type</cite>” property, the type’s display color, radius, and mass will be preconfigured (as if <a class="reference internal" href="#ovito.data.ParticleType.load_defaults" title="ovito.data.ParticleType.load_defaults"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_defaults()</span></code></a> was called).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">type_property</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s2">&quot;Particle Type&quot;</span><span class="p">)</span>
<span class="n">type_1</span> <span class="o">=</span> <span class="n">type_property</span><span class="o">.</span><span class="n">add_type_id</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">type_2</span> <span class="o">=</span> <span class="n">type_property</span><span class="o">.</span><span class="n">add_type_id</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>

<span class="c1"># Configure visual appearance of the two ParticleTypes</span>
<span class="n">type_1</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span> <span class="n">type_1</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">type_2</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">type_2</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Randomly assign types &quot;A&quot; (1) or &quot;B&quot; (2) to the particles</span>
<span class="n">type_property</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ovito.data.Property.add_type_name" title="ovito.data.Property.add_type_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_name()</span></code></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.0.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Property.add_type_name">
<span class="sig-name descname"><span class="pre">add_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><span class="pre">str</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">container</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><span class="pre">PropertyContainer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><span class="pre">ElementType</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><span class="pre">ParticleType</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#ovito.data.BondType" title="ovito.data.BondType"><span class="pre">BondType</span></a></span></span><a class="headerlink" href="#ovito.data.Property.add_type_name" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> with the given human-readable <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> and adds it to this property’s <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list. A unique numeric <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code></a> will be automatically assigned to the type (starting at 1). If the list already contains an existing element type of the same name, that existing type will be returned.</p>
<p>Additionally, you must specify the <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> containing this property object as second parameter, because it determines the kind of <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> to create. For example, when calling <a class="reference internal" href="#ovito.data.Property.add_type_name" title="ovito.data.Property.add_type_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_name()</span></code></a> on the property “<cite>Particle Type</cite>” of a <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> container, this method will create a new <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> object – a specific sub-class of the more general <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> class. Furthermore, if <em>name</em> matches one of the standard type names predefined for that particle property, e.g., a chemical symbol in case of the “<cite>Particle Type</cite>” property, the type’s display color, radius, and mass will be preconfigured (as if <a class="reference internal" href="#ovito.data.ParticleType.load_defaults" title="ovito.data.ParticleType.load_defaults"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_defaults()</span></code></a> was called).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">type_property</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s2">&quot;Particle Type&quot;</span><span class="p">)</span>
<span class="n">type_Au</span> <span class="o">=</span> <span class="n">type_property</span><span class="o">.</span><span class="n">add_type_name</span><span class="p">(</span><span class="s2">&quot;Au&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">)</span>
<span class="n">type_Ag</span> <span class="o">=</span> <span class="n">type_property</span><span class="o">.</span><span class="n">add_type_name</span><span class="p">(</span><span class="s2">&quot;Ag&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">)</span>

<span class="c1"># Randomly assign types &quot;Au&quot; or &quot;Ag&quot; to the particles</span>
<span class="n">type_property</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="n">type_Au</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">type_Ag</span><span class="o">.</span><span class="n">id</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.Property.add_type_id" title="ovito.data.Property.add_type_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_id()</span></code></a></p></li>
<li><p><a class="reference internal" href="../introduction/examples/file_readers/example_file_format_reader.html#example-custom-file-reader-fr1"><span class="std std-ref">Example FR1: Custom file reader loading particle properties and the simulation cell</span></a></p></li>
</ul>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.0.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Property.component_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">component_count</span></span><a class="headerlink" href="#ovito.data.Property.component_count" title="Permalink to this definition"></a></dt>
<dd><p>The number of vector components if this is a vector property; or 1 if this is a scalar property.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Property.component_names">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">component_names</span></span><a class="headerlink" href="#ovito.data.Property.component_names" title="Permalink to this definition"></a></dt>
<dd><p>The list of component names if this is a vectorial property. For example, the <code class="docutils literal notranslate"><span class="pre">Position</span></code> particle property has three components: <code class="docutils literal notranslate"><span class="pre">['X',</span> <span class="pre">'Y',</span> <span class="pre">'Z']</span></code>.</p>
<p>The number of elements in this list must always be equal to <a class="reference internal" href="#ovito.data.Property.component_count" title="ovito.data.Property.component_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">component_count</span></code></a> or zero, in which case the property components are referenced by numeric index (1, 2, 3, …).</p>
<p>For <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">predefined standard properties</span></a>, OVITO automatically initializes the components list.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Property.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#ovito.data.Property.name" title="Permalink to this definition"></a></dt>
<dd><p>The name of the property – a non-empty string.</p>
<p>The name may contain spaces, digits, or special characters, but no dots, because <code class="docutils literal notranslate"><span class="pre">.</span></code> is used in OVITO as a delimiter for vector <a class="reference internal" href="#ovito.data.Property.component_names" title="ovito.data.Property.component_names"><code class="xref py py-attr docutils literal notranslate"><span class="pre">component_names</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Property.type_by_id">
<span class="sig-name descname"><span class="pre">type_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Property.type_by_id" title="Permalink to this definition"></a></dt>
<dd><p>Looks up and returns the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> with the given unique numeric ID in this property’s <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.
Depending on the parameter <em>raise_error</em>, raises a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> or returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if no type with the numeric ID exists.</p>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Iterate over the numeric per-particle types stored in the &#39;Structure Type&#39;</span>
<span class="c1"># particle property array and print the corresponding human-readable type names:</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">type_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">structure_types</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Atom </span><span class="si">{}</span><span class="s2"> is a </span><span class="si">{}</span><span class="s2"> atom&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">structure_types</span><span class="o">.</span><span class="n">type_by_id</span><span class="p">(</span><span class="n">type_id</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</pre></div>
</div>
<p>An <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">“underscore” version</span></a> of the method exists, which should be used whenever you intend to modify the returned type object. <code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_id_()</span></code> implicitly calls <a class="reference internal" href="#ovito.data.DataObject.make_mutable" title="ovito.data.DataObject.make_mutable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_mutable()</span></code></a> on the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> to make sure it can be changed without unexpected side effects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Give some names to the numeric atom types from a LAMMPS simulation:</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span><span class="o">.</span><span class="n">type_by_id_</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.Property.type_by_name">
<span class="sig-name descname"><span class="pre">type_by_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.Property.type_by_name" title="Permalink to this definition"></a></dt>
<dd><p>Looks up and returns the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> with the given name in this property’s <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.
If multiple types exists with the same name, the first type is returned. 
Depending on the parameter <em>raise_error</em>, raises a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> or returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if there isn’t a type with that name.</p>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Look up the numeric ID of atom type Si and count how many times it appears in the &#39;Particle Type&#39; array</span>
<span class="n">id_Si</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span><span class="o">.</span><span class="n">type_by_name</span><span class="p">(</span><span class="s1">&#39;Si&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">id</span>
<span class="n">Si_atom_count</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">particle_types</span> <span class="o">==</span> <span class="n">id_Si</span><span class="p">)</span>
</pre></div>
</div>
<p>An <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">“underscore” version</span></a> of the method exists, which should be used whenever you intend to modify the returned type object. <code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_name_()</span></code> implicitly calls <a class="reference internal" href="#ovito.data.DataObject.make_mutable" title="ovito.data.DataObject.make_mutable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_mutable()</span></code></a> on the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> to make sure it can be changed without unexpected side effects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Rename a structure type created by the PTM modifier:</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">structure_types_</span><span class="o">.</span><span class="n">type_by_name_</span><span class="p">(</span><span class="s1">&#39;Hexagonal diamond&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Wurtzite&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.Property.types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">types</span></span><a class="headerlink" href="#ovito.data.Property.types" title="Permalink to this definition"></a></dt>
<dd><p>The list of <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> descriptors if this property is a <a class="reference internal" href="#typed-properties"><span class="std std-ref">typed property</span></a>.</p>
<p>A <em>typed property</em>, such as the <a class="reference external" href="../../reference/pipelines/data_objects/particles.html#scene-objects-particle-types" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">“Particle Type” property for particles</span></a>, stores each particle’s type information, for example its chemical type, in the form of a numeric <em>type ID</em> in the uniform data array. The <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list represents a look-up table containing a descriptor for each unique numeric type, which maps the numeric IDs to corresponding human-readable type names, chemical element symbols for example.</p>
<p>The <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list consists of instances of the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> class or one of its sub-classes, describing the attributes of individual types. For each unique type, the field <a class="reference internal" href="#ovito.data.ElementType.id" title="ovito.data.ElementType.id"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ElementType.id</span></code></a> specifies its numeric identifier and <a class="reference internal" href="#ovito.data.ElementType.name" title="ovito.data.ElementType.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ElementType.name</span></code></a> its human-readable name. Additionally, <a class="reference internal" href="#ovito.data.ElementType.color" title="ovito.data.ElementType.color"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ElementType.color</span></code></a> specifies the color used for rendering elements of this type.</p>
<p>Certain <em>typed properties</em> in OVITO use a sub-class of <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> to associate additional information with each unique type. For example, the “<cite>Particle Type</cite>” property array of <a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a> uses the <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a> class, which defines additional fields <a class="reference internal" href="#ovito.data.ParticleType.radius" title="ovito.data.ParticleType.radius"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticleType.radius</span></code></a> and <a class="reference internal" href="#ovito.data.ParticleType.mass" title="ovito.data.ParticleType.mass"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ParticleType.mass</span></code></a> for each type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The type descriptors are stored in arbitrary order in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list.   Therefore, you should never use a numeric type ID as an index into this list to look up the corresponding type descriptor.   Instead, use the <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_id()</span></code></a> method to quickly find the <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a> corresponding to a given numeric type ID.</p>
</div>
<p>If you want to manipulate the descriptors in the <a class="reference internal" href="#ovito.data.Property.types" title="ovito.data.Property.types"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types</span></code></a> list one by one, you should iterate over the <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">“underscore” version</span></a> of the list, <code class="xref py py-attr docutils literal notranslate"><span class="pre">types_</span></code>, to automatically make all the type descriptors mutable. This shortcut implicitly invokes <a class="reference internal" href="#ovito.data.DataObject.make_mutable" title="ovito.data.DataObject.make_mutable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_mutable()</span></code></a> on each <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a>, making sure it can be modified without unexpected side effects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get a mutable reference to the &quot;Particle Type&quot; property array.</span>
<span class="n">type_property</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">particle_types_</span>

<span class="c1"># Iterate over all defined ParticleType descriptors and modify their radius.</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">type_property</span><span class="o">.</span><span class="n">types_</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">radius</span> <span class="o">*=</span> <span class="mf">0.5</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>Type descriptor lookup: <a class="reference internal" href="#ovito.data.Property.type_by_id" title="ovito.data.Property.type_by_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_id()</span></code></a>, <a class="reference internal" href="#ovito.data.Property.type_by_name" title="ovito.data.Property.type_by_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type_by_name()</span></code></a></p></li>
<li><p>Adding new types: <a class="reference internal" href="#ovito.data.Property.add_type_id" title="ovito.data.Property.add_type_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_id()</span></code></a>, <a class="reference internal" href="#ovito.data.Property.add_type_name" title="ovito.data.Property.add_type_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_type_name()</span></code></a></p></li>
<li><p>Variants of type descriptors: <a class="reference internal" href="#ovito.data.ElementType" title="ovito.data.ElementType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementType</span></code></a>, <a class="reference internal" href="#ovito.data.ParticleType" title="ovito.data.ParticleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParticleType</span></code></a>, <a class="reference internal" href="#ovito.data.BondType" title="ovito.data.BondType"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondType</span></code></a></p></li>
</ul>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.PropertyContainer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">PropertyContainer</span></span><a class="headerlink" href="#ovito.data.PropertyContainer" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>A dictionary-like object storing a set of <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> objects.</p>
<p>It implements the <code class="docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code> interface. That means it can be used
like a standard read-only Python <code class="docutils literal notranslate"><span class="pre">dict</span></code> object to access the properties by name, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="n">positions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span>
<span class="n">has_selection</span> <span class="o">=</span> <span class="s1">&#39;Selection&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span>
<span class="n">name_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p>New properties are typically added to a container with a call to <a class="reference internal" href="#ovito.data.PropertyContainer.create_property" title="ovito.data.PropertyContainer.create_property"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code></a> as described <a class="reference internal" href="../introduction/data_manipulation.html#creating-new-properties"><span class="std std-ref">here</span></a>.
To remove an existing property from a container, you can use Python’s <code class="docutils literal notranslate"><span class="pre">del</span></code> statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="p">[</span><span class="s1">&#39;Selection&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>OVITO has several concrete implementations of the abstract <code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code> interface:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.DataTable" title="ovito.data.DataTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataTable</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.Lines" title="ovito.data.Lines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lines</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh.vertices" title="ovito.data.SurfaceMesh.vertices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.vertices</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh.faces" title="ovito.data.SurfaceMesh.faces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.faces</span></code></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh.regions" title="ovito.data.SurfaceMesh.regions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.regions</span></code></a></p></li>
</ul>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.PropertyContainer.count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">count</span></span><a class="headerlink" href="#ovito.data.PropertyContainer.count" title="Permalink to this definition"></a></dt>
<dd><p>The number of data elements in this container, e.g. the number of particles. This value is always equal to the lengths of all <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> arrays managed by this container.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.PropertyContainer.create_property">
<span class="sig-name descname"><span class="pre">create_property</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.PropertyContainer.create_property" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new property with the given <em>name</em> to the container and optionally initializes its element-wise values with <em>data</em>.
If a property with the given <em>name</em> already exists in the container, that existing property is returned
(after replacing its contents with <em>data</em> if provided).</p>
<p>You can create <em>standard</em> and <em>user-defined</em> properties in a container.
A <em>standard</em> property with a prescribed data layout is automatically created if <em>name</em> matches one of the
predefined names for the container type:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#ovito.data.Particles" title="ovito.data.Particles"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particles</span></code></a>: <a class="reference internal" href="#particle-properties-list"><span class="std std-ref">List of standard particle properties</span></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.Bonds" title="ovito.data.Bonds"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bonds</span></code></a>: <a class="reference internal" href="#bond-types-list"><span class="std std-ref">List of standard bond properties</span></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh.vertices" title="ovito.data.SurfaceMesh.vertices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.vertices</span></code></a>: <a class="reference internal" href="#surface-mesh-vertex-properties-list"><span class="std std-ref">List of standard mesh vertex properties</span></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh.faces" title="ovito.data.SurfaceMesh.faces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.faces</span></code></a>: <a class="reference internal" href="#surface-mesh-face-properties-list"><span class="std std-ref">List of standard mesh face properties</span></a></p></li>
<li><p><a class="reference internal" href="#ovito.data.SurfaceMesh.regions" title="ovito.data.SurfaceMesh.regions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.regions</span></code></a>: <a class="reference internal" href="#surface-mesh-region-properties-list"><span class="std std-ref">List of standard mesh region properties</span></a></p></li>
</ul>
</div></blockquote>
<p>The length of the provided <em>data</em> array must match the number of elements in the container, which is given by <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PropertyContainer.count</span></code></a>.
If the property to be created is a vectorial property (having <span class="math notranslate nohighlight">\(M&gt;1\)</span> components), the initial data
array should be of shape <span class="math notranslate nohighlight">\((N,M)\)</span> if provided:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Color&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
</pre></div>
</div>
<p>In general, however, <em>data</em> may be any value that is broadcastable to the array dimensions of the standard property (e.g. a uniform value).</p>
<p>If you don’t specify the function argument <em>data</em>, OVITO will automatically initialize the property elements with sensible default
values (0 in most cases). Subsequently, you can set the property values for all or some of the elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Color&#39;</span><span class="p">)</span>
<span class="n">prop</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a <em>user-defined</em> property, specify a non-standard property name:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;My Integer Property&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, the data type and the number of vector components of the new property are inferred from
the provided NumPy array. Specifying a one-dimensional array creates a scalar property whereas
a two-dimensional array creates a vectorial property.
Alternatively, the <em>dtype</em> and <em>components</em> parameters can be specified explicitly
if you are going to set the property values at a later time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;My Vector Property&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">prop</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>If the property to be created already exists in the container, it gets replaced with a <a class="reference internal" href="../introduction/data_manipulation.html#data-ownership"><span class="std std-ref">modifiable copy</span></a> if necessary.
The values of the property get overwritten with <em>data</em> in this case.</p>
<p>Note: If you’re creating new <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>, its element <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> is 0 initially.
In this state the <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_property()</span></code> method allows you to initialize the count while adding the very first property
by providing a data array of the desired length:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># An empty Particles container to begin with:</span>
<span class="n">particles</span> <span class="o">=</span> <span class="n">Particles</span><span class="p">()</span>

<span class="c1"># Create 10 particles with random xyz coordinates:</span>
<span class="n">xyz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">particles</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Position&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">particles</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
</pre></div>
</div>
<p>All properties subsequently added to the container must have the same length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – Name of the property to create.</p></li>
<li><p><strong>data</strong> – Optional array with initial values for the new property.
The size of the array must match the element <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> of the container
and the shape must be consistent with the number of components of the property to be created.</p></li>
<li><p><strong>dtype</strong> – Data type of the user-defined property. Must be <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.int8</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.int32</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.int64</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code>, or <code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code>.</p></li>
<li><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – Number of vector components of the user-defined property (1 if not specified).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.PropertyContainer.delete_elements">
<span class="sig-name descname"><span class="pre">delete_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.PropertyContainer.delete_elements" title="Permalink to this definition"></a></dt>
<dd><p>Deletes a subset of the elements from this container. The elements to be deleted must be specified in terms
of a 1-dimensional mask array having the same length as the container (see <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a>).
The method will delete those elements whose corresponding mask value is non-zero, i.e., the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th element
will be deleted if <code class="docutils literal notranslate"><span class="pre">mask[i]!=0</span></code>.</p>
<p>For example, to delete all currently selected particles, i.e., the subset of particles whose <code class="docutils literal notranslate"><span class="pre">Selection</span></code> property
is non-zero, one would simply write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">delete_elements</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="s1">&#39;Selection&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The effect of this statement is the same as for applying the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.DeleteSelectedModifier" title="ovito.modifiers.DeleteSelectedModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeleteSelectedModifier</span></code></a> to the particles list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.PropertyContainer.delete_indices">
<span class="sig-name descname"><span class="pre">delete_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.PropertyContainer.delete_indices" title="Permalink to this definition"></a></dt>
<dd><p>Deletes a subset of the elements from this container. The elements to be deleted must be specified in terms
of a sequence of indices, all in the range 0 to <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a>-1. The method accepts any type of iterable object,
including sequence types and generators.</p>
<p>For example, to delete every other particle, one could use Python’s <code class="docutils literal notranslate"><span class="pre">range()</span></code> function to generate
all even indices up to the length of the particle container:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">particles_</span><span class="o">.</span><span class="n">delete_indices</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.PropertyContainer.title">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">title</span></span><a class="headerlink" href="#ovito.data.PropertyContainer.title" title="Permalink to this definition"></a></dt>
<dd><p>The title of the data object under which it appears in the user interface of OVITO.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.SimulationCell">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">SimulationCell</span></span><a class="headerlink" href="#ovito.data.SimulationCell" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>This object stores the geometric shape and boundary conditions of the simulation box.
Typically there is exactly one <code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code> object in a <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>, which is accessible through 
the <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="o">...</span><span class="p">])</span>   <span class="c1"># Use [...] to cast SimulationCell object to a NumPy array</span>
</pre></div>
</div>
<p class="rubric">The cell matrix</p>
<p>The geometry of the simulation cell is encoded as a 3x4 matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>. 
The first three columns <span class="math notranslate nohighlight">\(\mathbf{a}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> of the matrix are the vectors spanning the three-dimensional parallelepiped
in Cartesian space. The fourth column specifies the Cartesian coordinates of the cell’s origin <span class="math notranslate nohighlight">\(\mathbf{o}\)</span> within the global
simulation coordinate system:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{M} = \begin{pmatrix}
   a_x &amp; b_x &amp; c_x &amp; o_x \\
   a_y &amp; b_y &amp; c_y &amp; o_y \\
   a_z &amp; b_z &amp; c_z &amp; o_z \\
   \end{pmatrix}\end{split}\]</div>
<p>The cell matrix is represented by a two-dimensional NumPy array of shape (3,4) using row-major storage order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">o</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ovito.data.SimulationCell.is2D" title="ovito.data.SimulationCell.is2D"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is2D</span></code></a> flag of the simulation cell indicates whether the system is two-dimensional. 
The cell matrix of a 2d system also has the 3x4 shape, but the cell vector <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> and the 
last row of the cell matrix are ignored by many computations in OVITO if the system is marked as 2d.</p>
<p class="rubric">Periodic boundary conditions</p>
<p>The <a class="reference internal" href="#ovito.data.SimulationCell.pbc" title="ovito.data.SimulationCell.pbc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc</span></code></a> field stores a tuple of three Boolean flags that indicate for each 
cell vector whether the system is periodic in that direction or not. OVITO uses that information
in various computations. If the system is two-dimensional, the value of the third pbc flag
is ignored.</p>
<p class="rubric">Modifying the simulation cell</p>
<p>When you modify the entries of the cell matrix, make sure you use the <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">underscore notation</span></a> 
to request a modifiable version of the <code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make cell twice as large along the Y direction by scaling the second cell vector:</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>Reset the simulation cell to an orthogonal box <span class="math notranslate nohighlight">\((L_x, L_y, L_z)\)</span> centered at the origin:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lx</span> <span class="o">=</span> <span class="mf">20.0</span><span class="p">;</span> <span class="n">ly</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span> <span class="n">lz</span> <span class="o">=</span> <span class="mf">8.0</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lz</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell_</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Conversion between Cartesian and reduced coordinates</p>
<p>Given a point in 3d space, <span class="math notranslate nohighlight">\(\mathbf{p}=(x, y, z)\)</span>, expressed in coordinates of the Cartesian simulation system, you can compute
the corresponding reduced cell coordinates by extending the point to a quadruplet <span class="math notranslate nohighlight">\((x, y, z, 1)\)</span> and multiplying it 
with the <a class="reference internal" href="#ovito.data.SimulationCell.inverse" title="ovito.data.SimulationCell.inverse"><code class="xref py py-attr docutils literal notranslate"><span class="pre">inverse</span></code></a> cell matrix <span class="math notranslate nohighlight">\(\mathbf{M}^*\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_cartesian</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">p_reduced</span>   <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">inverse</span> <span class="o">@</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_cartesian</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># @-operator is shorthand for numpy.matmul()</span>
</pre></div>
</div>
<p>This effectively performs an affine transformation. The reverse transformation back to Cartesian coordinates in the global simulation system 
works in the same way. The following operation converts a 3d point from reduced cell coordinates to simulation coordinates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_reduced</span>   <span class="o">=</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">)</span>
<span class="n">p_cartesian</span> <span class="o">=</span> <span class="n">cell</span> <span class="o">@</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_reduced</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># @-operator is shorthand for numpy.matmul()</span>
</pre></div>
</div>
<p>Transforming vectors (as opposed to points) between Cartesian and reduced cell coordinates works somewhat differently, because vectors 
are not affected by the translation of the simulation cell, i.e., when the cell’s origin does not coincide with the origin of the global simulation coordinate system.
A vector  <span class="math notranslate nohighlight">\(\mathbf{v}=(x, y, z)\)</span> should thus be amended with a zero, <span class="math notranslate nohighlight">\((x, y, z, 0)\)</span>, before applying the 3x4 transformation matrix
to ignore the translational component:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_cartesian</span>     <span class="o">=</span> <span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span><span class="p">)</span>
<span class="n">v_reduced</span>       <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">inverse</span> <span class="o">@</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_cartesian</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">v_cartesian_out</span> <span class="o">=</span> <span class="n">cell</span> <span class="o">@</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_reduced</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>  
<span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v_cartesian_out</span><span class="p">,</span> <span class="n">v_cartesian</span><span class="p">)</span>
</pre></div>
</div>
<p>The operations described above transform individual 3d points or vectors. In case you have to transform an entire array of points or vectors,
for example the list of atomic positions, it is most efficient to apply the transformation to all elements of the array at once.
Here is how you can do the affine transformation back and forth between Cartesian and reduced coordinates for an array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cartesian_positions</span>     <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">particles</span><span class="o">.</span><span class="n">positions</span>
<span class="n">reduced_positions</span>       <span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">cartesian_positions</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">cell</span><span class="o">.</span><span class="n">inverse</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">cartesian_positions_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">reduced_positions</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cartesian_positions_out</span><span class="p">,</span> <span class="n">cartesian_positions</span><span class="p">)</span>
</pre></div>
</div>
<p>When transforming an array of vectors, leave away the translation term and perform just the linear transformation (3x3 matrix-vector multiplication).</p>
<p class="rubric">Visual representation</p>
<p>Each <code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code> object has an attached <a class="reference internal" href="ovito_vis.html#ovito.vis.SimulationCellVis" title="ovito.vis.SimulationCellVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCellVis</span></code></a> element,
which controls the visual appearance of the wireframe box in rendered images. It can be accessed via the
<a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vis</span></code></a> attribute inherited from the <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataObject</span></code></a> base class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
<span class="c1"># Change display color of simulation cell to red:</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">rendering_color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="c1"># Or turn off the display of the cell completely:</span>
<span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SimulationCell.delta_vector">
<span class="sig-name descname"><span class="pre">delta_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_pbcvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SimulationCell.delta_vector" title="Permalink to this definition"></a></dt>
<dd><p>Computes the vector connecting two points <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span> in a periodic simulation cell by applying the minimum image convention.</p>
<p>The method starts by computing the 3d vector <span class="math notranslate nohighlight">\({\Delta} = r_b - r_a\)</span> for two points <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span>, which may be located in different images
of the periodic simulation cell. The <a class="reference external" href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">minimum image convention</a>
is then applied to obtain the new vector <span class="math notranslate nohighlight">\({\Delta'} = r_b' - r_a\)</span>, where the original point <span class="math notranslate nohighlight">\(r_b\)</span> has been replaced by the periodic image
<span class="math notranslate nohighlight">\(r_b'\)</span> that is closest to <span class="math notranslate nohighlight">\(r_a\)</span>, making the vector <span class="math notranslate nohighlight">\({\Delta'}\)</span> as short as possible (in reduced coordinate space).
<span class="math notranslate nohighlight">\(r_b'\)</span> is obtained by translating <span class="math notranslate nohighlight">\(r_b\)</span> an integer number of times along each of the three cell directions:
<span class="math notranslate nohighlight">\(r_b' = r_b - H*n\)</span>, with <span class="math notranslate nohighlight">\(H\)</span> being the 3x3 cell matrix and <span class="math notranslate nohighlight">\(n\)</span> being a vector of three integers that are chosen by the
method such that <span class="math notranslate nohighlight">\(r_b'\)</span> is as close to <span class="math notranslate nohighlight">\(r_a\)</span> as possible.</p>
<p>Note that the periodic image convention is applied only along those cell directions for which
periodic boundary conditions are enabled (see <a class="reference internal" href="#ovito.data.SimulationCell.pbc" title="ovito.data.SimulationCell.pbc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc</span></code></a> property). For other directions
no shifting is performed, i.e., the corresponding components of <span class="math notranslate nohighlight">\(n = (n_x,n_y,n_z)\)</span> will always be zero.</p>
<p>The method is able to compute the results for either an individual pair of input points or for two <em>arrays</em> of input points. In the latter case,
i.e. if the input parameters <em>ra</em> and <em>rb</em> are both 2-D arrays of shape <em>Nx3</em>, the method returns a 2-D array containing
<em>N</em> output vectors. This allows applying the minimum image convention to a large number of point pairs in one function call.</p>
<p>The option <em>return_pbcvec</em> lets the method return the vector <span class="math notranslate nohighlight">\(n\)</span> introduced above as an additional output.
The components of this vector specify the number of times the image point <span class="math notranslate nohighlight">\(r_b'\)</span> needs to be shifted along each of the three cell directions
in order to bring it onto the original input point <span class="math notranslate nohighlight">\(r_b\)</span>. In other words, it specifies the number of times the
computed vector <span class="math notranslate nohighlight">\({\Delta} = r_b - r_a\)</span> crosses a periodic boundary of the cell (either in positive or negative direction).
For example, the PBC shift vector <span class="math notranslate nohighlight">\(n = (1,0,-2)\)</span> would indicate that, in order to get from input point <span class="math notranslate nohighlight">\(r_a\)</span> to input point <span class="math notranslate nohighlight">\(r_b\)</span>, one has to cross the
cell boundaries once in the positive x-direction and twice in the negative z-direction. If <em>return_pbcvec</em> is True,
the method returns the tuple (<span class="math notranslate nohighlight">\({\Delta'}\)</span>, <span class="math notranslate nohighlight">\(n\)</span>); otherwise it returns just <span class="math notranslate nohighlight">\({\Delta'}\)</span>.
Note that the vector <span class="math notranslate nohighlight">\(n\)</span> computed by this method can be used, for instance, to correctly initialize the <a class="reference internal" href="#ovito.data.Bonds.pbc_vectors" title="ovito.data.Bonds.pbc_vectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Bonds.pbc_vectors</span></code></a>
property for newly created bonds that cross a periodic cell boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ra</strong> – The Cartesian xyz coordinates of the first input point(s). Either a 1-D array of length 3 or a 2-D array of shape (<em>N</em>,3).</p></li>
<li><p><strong>rb</strong> – The Cartesian xyz coordinates of the second input point(s). Must have the same shape as <em>ra</em>.</p></li>
<li><p><strong>return_pbcvec</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a>) – If True, also returns the vector <span class="math notranslate nohighlight">\(n\)</span>, which specifies how often the vector <span class="math notranslate nohighlight">\((r_b' - r_a)\)</span> crosses the periodic cell boundaries.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The vector <span class="math notranslate nohighlight">\({\Delta'}\)</span> and, optionally, the vector <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd>
</dl>
<p>Note that there exists also a convenience method <a class="reference internal" href="#ovito.data.Particles.delta_vector" title="ovito.data.Particles.delta_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Particles.delta_vector()</span></code></a>,
which should be used in situations where <span class="math notranslate nohighlight">\(r_a\)</span> and <span class="math notranslate nohighlight">\(r_b\)</span> are the coordinates of two particles in the simulation cell.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SimulationCell.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#ovito.data.SimulationCell.inverse" title="Permalink to this definition"></a></dt>
<dd><p>Read-only property returning the reciprocal cell matrix <span class="math notranslate nohighlight">\(\mathbf{M}^*\)</span> - an array of shape (3,4):</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}^* = \begin{bmatrix} \mathbf{a}^* &amp; \mathbf{b}^* &amp; \mathbf{c}^* &amp; \mathbf{o}^* \end{bmatrix}\]</div>
<p>with the real-space cell volume <span class="math notranslate nohighlight">\(V = (\mathbf{a} \times \mathbf{b}) \cdot \mathbf{c}\)</span> and reciprocal cell vectors given by</p>
<div class="math notranslate nohighlight">
\[\mathbf{a}^* = \frac{\mathbf{b} \times \mathbf{c}}{V} \qquad
\mathbf{b}^* = \frac{\mathbf{c} \times \mathbf{a}}{V} \qquad
\mathbf{c}^* = \frac{\mathbf{a} \times \mathbf{b}}{V} \qquad
\mathbf{o}^* = -\begin{pmatrix} \mathbf{a}^* \; \mathbf{b}^* \; \mathbf{c}^* \end{pmatrix} \mathbf{o} \mathrm{.}\]</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SimulationCell.is2D">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is2D</span></span><a class="headerlink" href="#ovito.data.SimulationCell.is2D" title="Permalink to this definition"></a></dt>
<dd><p>Specifies whether the system is two-dimensional (instead of three-dimensional). For two-dimensional systems, the third <a class="reference internal" href="#ovito.data.SimulationCell.pbc" title="ovito.data.SimulationCell.pbc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pbc</span></code></a> flag and the cell vector <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> are typically ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SimulationCell.pbc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pbc</span></span><a class="headerlink" href="#ovito.data.SimulationCell.pbc" title="Permalink to this definition"></a></dt>
<dd><p>A tuple of three Boolean flags specifying whether periodic boundary conditions are enabled along the
cell’s three spatial directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">False,</span> <span class="pre">False)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SimulationCell.volume">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume</span></span><a class="headerlink" href="#ovito.data.SimulationCell.volume" title="Permalink to this definition"></a></dt>
<dd><p>Read-only property computing the volume of the three-dimensional simulation cell.
The returned value is equal to the absolute determinant of the 3x3 submatrix formed by the three cell vectors, i.e. the scalar triple product <span class="math notranslate nohighlight">\(V=|(\mathbf{a} \times \mathbf{b}) \cdot \mathbf{c}|\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">cell</span><span class="o">.</span><span class="n">volume</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SimulationCell.volume2D">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume2D</span></span><a class="headerlink" href="#ovito.data.SimulationCell.volume2D" title="Permalink to this definition"></a></dt>
<dd><p>Read-only property computing the area of the two-dimensional simulation cell (see <a class="reference internal" href="#ovito.data.SimulationCell.is2D" title="ovito.data.SimulationCell.is2D"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is2D</span></code></a>).
The returned value is equal to the magnitude of the cross-product of the first two cell vectors, i.e. <span class="math notranslate nohighlight">\(V_{\mathrm{2d}} = |\mathbf{a} \times \mathbf{b}|\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">cell</span><span class="o">.</span><span class="n">volume2D</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">cell</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">SurfaceMesh</span></span><a class="headerlink" href="#ovito.data.SurfaceMesh" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>This data object type represents a surface in three-dimensional space, i.e.. a two-dimensional manifold that is usually closed and orientable. 
The underlying representation of the surface is a discrete mesh made of vertices, edges, and planar faces. 
See the <a class="reference external" href="../../reference/pipelines/data_objects/surface_mesh.html#scene-objects-surface-mesh" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">user manual page on surface meshes</span></a> for more information on this data object type.</p>
<p>Surface meshes are typically produced by modifiers such as <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ConstructSurfaceModifier" title="ovito.modifiers.ConstructSurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructSurfaceModifier</span></code></a>, 
<a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CreateIsosurfaceModifier" title="ovito.modifiers.CreateIsosurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateIsosurfaceModifier</span></code></a>, <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CoordinationPolyhedraModifier" title="ovito.modifiers.CoordinationPolyhedraModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinationPolyhedraModifier</span></code></a> or 
<a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.VoronoiAnalysisModifier" title="ovito.modifiers.VoronoiAnalysisModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoronoiAnalysisModifier</span></code></a>.</p>
<p>Each surface mesh has a unique <a class="reference internal" href="#ovito.data.DataObject.identifier" title="ovito.data.DataObject.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> by which it can be looked up in the 
<a class="reference internal" href="#ovito.data.DataCollection.surfaces" title="ovito.data.DataCollection.surfaces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.surfaces</span></code></a> dictionary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply a CreateIsosurfaceModifier to a VoxelGrid to create a SurfaceMesh:</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CreateIsosurfaceModifier</span><span class="p">(</span><span class="n">operate_on</span><span class="o">=</span><span class="s1">&#39;voxels:charge-density&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="s1">&#39;Charge density&#39;</span><span class="p">,</span> <span class="n">isolevel</span><span class="o">=</span><span class="mf">0.05</span><span class="p">))</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="c1"># The SurfaceMesh created by the modifier has the identifier &#39;isosurface&#39;:</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="p">[</span><span class="s1">&#39;isosurface&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Vertices, halfedges, and faces</strong></p>
<p>A surface mesh is made of a set of <cite>vertices</cite>, a set of directed <cite>halfedges</cite> each connecting two vertices, and 
a set of <cite>faces</cite>, each formed by a circular sequence of halfedges. The connectivity information, i.e., which vertices
are connected by halfedges and which halfedges form the faces, is stored in the <a class="reference internal" href="#ovito.data.SurfaceMesh.topology" title="ovito.data.SurfaceMesh.topology"><code class="xref py py-attr docutils literal notranslate"><span class="pre">topology</span></code></a> sub-object of the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a>.
See the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology" title="ovito.data.SurfaceMeshTopology"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMeshTopology</span></code></a> class for more information.</p>
<p>Vertices and faces of the surface mesh can be associated with arbitrary property values, similar to how particles can 
have arbitrary properties assigned to them in OVITO. These properties are managed by the <a class="reference internal" href="#ovito.data.SurfaceMesh.vertices" title="ovito.data.SurfaceMesh.vertices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vertices</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMesh.faces" title="ovito.data.SurfaceMesh.faces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">faces</span></code></a>
<a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> sub-objects of the surface mesh. The vertices of the mesh are always associated with the property named
<code class="docutils literal notranslate"><span class="pre">Position</span></code>, which stores the three-dimensional coordinates of each vertex, similar to the <code class="docutils literal notranslate"><span class="pre">Position</span></code> property of particles
in OVITO.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vertex_coords</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="ovito_vis.html#ovito.vis.SurfaceMeshVis" title="ovito.vis.SurfaceMeshVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMeshVis</span></code></a> element, which is responsible for rendering the surface mesh,
provides the option to visualize local vertex and face property values using a color mapping scheme.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">color_mapping_mode</span> <span class="o">=</span> <span class="n">SurfaceMeshVis</span><span class="o">.</span><span class="n">ColorMappingMode</span><span class="o">.</span><span class="n">Vertex</span>
<span class="n">surface</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">color_mapping_property</span> <span class="o">=</span> <span class="s1">&#39;Position.Z&#39;</span>
<span class="n">surface</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">color_mapping_interval</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">vertex_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">vertex_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p>If you want to modify property values of the mesh, keep in mind that you have to use <a class="reference internal" href="../introduction/data_manipulation.html#underscore-notation"><span class="std std-ref">underscore notation</span></a>, 
for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="p">[</span><span class="s1">&#39;isosurface_&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vertices_</span><span class="p">[</span><span class="s1">&#39;Position_&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xoffset</span><span class="p">,</span> <span class="n">yoffset</span><span class="p">,</span> <span class="n">zoffset</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Periodic simulation domains</strong></p>
<p>A surface mesh may be embedded in a periodic domain, i.e. in a simulation cell with periodic boundary conditions. 
That means edges and faces of the surface mesh can connect vertices on opposite sides of the simulation box and will wrap around correctly. 
OVITO takes care of computing the intersections of such a periodic surface with the box boundaries and automatically produces a non-periodic 
representation of the mesh when it comes to displaying the surface. If needed, you can explicitly request a non-periodic version of the mesh, which 
was clipped at the periodic box boundaries, by calling the <a class="reference internal" href="#ovito.data.SurfaceMesh.to_triangle_mesh" title="ovito.data.SurfaceMesh.to_triangle_mesh"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_triangle_mesh()</span></code></a> method from a script.</p>
<p>The spatial domain of the surface mesh is the <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object stored in its <a class="reference internal" href="#ovito.data.SurfaceMesh.domain" title="ovito.data.SurfaceMesh.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.domain</span></code></a> field. 
Note that this attached <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> may, in some situations, not be identical with the global simulation 
<a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> set for the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>.</p>
<p><strong>Spatial regions</strong></p>
<p>If it is a closed, orientable manifold the surface mesh subdivides three-dimensional space into separate spatial regions. 
For example, if the surface mesh was constructed by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ConstructSurfaceModifier" title="ovito.modifiers.ConstructSurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructSurfaceModifier</span></code></a> from a set of input particles, 
then the volume enclosed by the surface is the “filled” interior region and the exterior space is the “empty” region containing no particles.</p>
<p>In general, the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> class manages a variable list of <a class="reference internal" href="#ovito.data.SurfaceMesh.regions" title="ovito.data.SurfaceMesh.regions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">regions</span></code></a>, each being identified by a numeric, zero-based index.
The <a class="reference internal" href="#ovito.data.SurfaceMesh.locate_point" title="ovito.data.SurfaceMesh.locate_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">locate_point()</span></code></a> method allows to determine which spatial region some point in space belongs to.</p>
<p>A surface mesh may be degenerate, which means it contains no vertices and faces. In such a case there is only one spatial region filling entire space. For example, 
when there exist no input particles, the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ConstructSurfaceModifier" title="ovito.modifiers.ConstructSurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructSurfaceModifier</span></code></a> is unable to construct a regular surface mesh and
the “empty” region fills the entire simulation cell. Conversely, if the periodic simulation cell is completely filled with particles,
the “filled” region covers the entire periodic simulation domain and the resulting surface mesh consists of no vertices or faces, i.e., it is also degenerate.
To discriminate between the two situations, the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> class has a <a class="reference internal" href="#ovito.data.SurfaceMesh.space_filling_region" title="ovito.data.SurfaceMesh.space_filling_region"><code class="xref py py-attr docutils literal notranslate"><span class="pre">space_filling_region</span></code></a> field, which specifies
the spatial region that fills entire space in cases where the mesh is degenerate.</p>
<p><strong>File export</strong></p>
<p>A surface mesh may be exported to a geometry file in the form of a triangle mesh using OVITO’s <a class="reference internal" href="ovito_io.html#ovito.io.export_file" title="ovito.io.export_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_file()</span></code></a> function. 
To this end, a non-periodic version is produced by truncating triangles at the domain boundaries and generating “cap polygons” filling the holes that 
occur at the intersection of the surface with periodic domain boundaries. The following example code writes a VTK geometry file 
(<code class="docutils literal notranslate"><span class="pre">vtk/trimesh</span></code> export format):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="kn">import</span> <span class="n">import_file</span><span class="p">,</span> <span class="n">export_file</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="kn">import</span> <span class="n">SurfaceMesh</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="kn">import</span> <span class="n">ConstructSurfaceModifier</span>

<span class="c1"># Load a particle set and construct the surface mesh:</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;input/simulation.dump&quot;</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ConstructSurfaceModifier</span><span class="p">(</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">2.8</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span><span class="o">.</span><span class="n">surfaces</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">]</span>

<span class="c1"># Export the mesh to a VTK file for visualization with ParaView.</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;output/surface_mesh.vtk&#39;</span><span class="p">,</span> <span class="s1">&#39;vtk/trimesh&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Clipping planes</strong></p>
<p>A set of <em>clipping planes</em> can be assigned to a <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> to clip away parts of the mesh for visualization purposes.
This may be useful to e.g. cut a hole into a closed surface allowing to look inside the enclosed volume.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code> objects manages a list of clipping planes, which is accessible through the <a class="reference internal" href="#ovito.data.SurfaceMesh.get_clipping_planes" title="ovito.data.SurfaceMesh.get_clipping_planes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_clipping_planes()</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMesh.set_clipping_planes" title="ovito.data.SurfaceMesh.set_clipping_planes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_clipping_planes()</span></code></a>
methods. Note that the cut operations are non-destructive and get performed only on the transient, non-periodic version of the mesh generated during image rendering or when exporting 
the mesh to a file. The original surface mesh is not affected.
The <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.SliceModifier" title="ovito.modifiers.SliceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">SliceModifier</span></code></a>, when applied to a <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>, performs the slice by simply adding a corresponding clipping plane 
to the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>. The actual truncation of the mesh happens later on, during the final visualization step, when a non-periodic version is computed.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.connect_opposite_halfedges">
<span class="sig-name descname"><span class="pre">connect_opposite_halfedges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><span class="pre">bool</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.connect_opposite_halfedges" title="Permalink to this definition"></a></dt>
<dd><p>Links together pairs of halfedges in the mesh to form a two-dimensional manifold made of connected faces. For each halfedge <span class="math notranslate nohighlight">\(a \to b\)</span> the method tries to find the corresponding reverse halfedge <span class="math notranslate nohighlight">\(b \to a\)</span>, which bounds the adjacent face. The two halfedges are then linked together to form a pair. The method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> to indicate that all halfedges of the mesh have been successfully associated with a corresponding opposite halfedge. In this case, the mesh is said to be <em>closed</em>, i.e., its faces form a contiguous manifold.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>For this method to work, the faces of the mesh must have been created all with the same winding order. That means their vertices   must consistently be ordered counter-clockwise when viewed from the outside of the closed surface manifold (the front side).   Only then do the halfedges of adjacent faces run in opposite directions and can be successfully paired by this method.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ovito.data.SurfaceMeshTopology.is_closed" title="ovito.data.SurfaceMeshTopology.is_closed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMeshTopology.is_closed</span></code></a>, <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.opposite_edge" title="ovito.data.SurfaceMeshTopology.opposite_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMeshTopology.opposite_edge()</span></code></a>, <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.has_opposite_edge" title="ovito.data.SurfaceMeshTopology.has_opposite_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMeshTopology.has_opposite_edge()</span></code></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.create_face">
<span class="sig-name descname"><span class="pre">create_face</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.26)"><span class="pre">numpy.ndarray</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.create_face" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new face to the mesh. <em>vertices</em> must be a sequence of two or more zero-based indices into the mesh’s vertex list. The method creates a loop of halfedges connecting the given vertices to form a closed polygon. The zero-based index of the newly created face is returned.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you intend to add several faces to the mesh, consider using <a class="reference internal" href="#ovito.data.SurfaceMesh.create_faces" title="ovito.data.SurfaceMesh.create_faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_faces()</span></code></a> instead.   It is potentially much faster than calling <a class="reference internal" href="#ovito.data.SurfaceMesh.create_face" title="ovito.data.SurfaceMesh.create_face"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_face()</span></code></a> multiple times.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Visible faces should be made of three or more vertices that form a convex polygon.   Faces that represent a non-convex polygon will likely be rendered incorrectly by OVITO.   Faces having only two edges, while technically valid, will not get rendered because they are degenerate.</p>
<p>The vertex winding order used by OVITO is counter-clockwise on the front side of mesh faces. When constructing a closed mesh,   make sure you always specify vertices in counter-clockwise order when viewed from the outside of enclosed region.</p>
</div>
<p><strong>Code example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add a new SurfaceMesh object to the DataCollection with unique object identifier &#39;quad&#39;.</span>
<span class="c1"># The simulation cell of the particle system is adopted also as domain of the SurfaceMesh.</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;quad&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Quad&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

<span class="c1"># Create 4 mesh vertices forming a quadrilateral.</span>
<span class="n">verts</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">create_vertices</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>

<span class="c1"># Create a face connecting the 4 vertices.</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">create_face</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># Initialize the &#39;Color&#39; property of the newly created face.</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Color&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.create_faces">
<span class="sig-name descname"><span class="pre">create_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex_lists</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.26)"><span class="pre">numpy.ndarray</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.create_faces" title="Permalink to this definition"></a></dt>
<dd><p>Adds several new polygonal faces to the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vertex_lists</strong> – A sequence of sequences, one for each face to be created, which specify the vertex indices to be connected by the new mesh faces.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Index of the first newly created face.</p>
</dd>
</dl>
<p><em>vertex_lists</em> may be list of tuples for example. The following call creates a 3-sided and a 4-sided polygonal face:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">create_faces</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)])</span>
</pre></div>
</div>
<p>For best performance, pass a two-dimensional NumPy array to create multiple faces which all have the same number of vertices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Nx3 array [[0,1,2], [3,4,5], [6,7,8], ...] for connecting 3N vertices with triangle faces.</span>
<span class="n">triangle_list</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">count</span><span class="o">//</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">create_faces</span><span class="p">(</span><span class="n">triangle_list</span><span class="p">)</span>
</pre></div>
</div>
<p>A third option is to specify the faces as one linear array, in which each face’s vertex list is prefixed with the number of vertices. For example, to create a 3-sided face <em>0-1-2</em> and a 4-sided face <em>3-4-5-6</em>, one would write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">create_faces</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]))</span>
</pre></div>
</div>
<p>Note that the data <em>must</em> be provided as a NumPy array in this case, not a Python list.</p>
<p>The <a class="reference internal" href="#ovito.data.SurfaceMesh.create_faces" title="ovito.data.SurfaceMesh.create_faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_faces()</span></code></a> method has two effects: It increments the mesh’s <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.face_count" title="ovito.data.SurfaceMeshTopology.face_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">topology.face_count</span></code></a> and it extends the arrays in the mesh’s <a class="reference internal" href="#ovito.data.SurfaceMesh.faces" title="ovito.data.SurfaceMesh.faces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">faces</span></code></a> property container, which stores all per-face properties. The method raises an error if any of the specified vertex indices does not exist in the mesh. That means you should first call <a class="reference internal" href="#ovito.data.SurfaceMesh.create_vertices" title="ovito.data.SurfaceMesh.create_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_vertices()</span></code></a> to add vertices to the mesh before creating faces referencing these vertices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Visible faces should be made of three or more vertices forming convex polygons.   Faces that represent non-convex polygons will likely be rendered incorrectly by OVITO.   Faces having only two edges, while technically valid, will not get rendered because they are degenerate.</p>
<p>The vertex winding order used by OVITO is counter-clockwise on the front side of mesh faces. When constructing a closed mesh,   make sure you always specify vertices in counter-clockwise order when viewed from the outside of enclosed region.</p>
</div>
<p><strong>Usage example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add a new SurfaceMesh object to the DataCollection with unique object identifier &#39;tetrahedron&#39;.</span>
<span class="c1"># The simulation cell of the particle system is adopted also as domain of the SurfaceMesh.</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">surfaces</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;tetrahedron&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Tetrahedron&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

<span class="c1"># Create 4 mesh vertices.</span>
<span class="n">verts</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">]]</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">create_vertices</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>

<span class="c1"># Create 4 triangular faces forming a tetrahedron.</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">create_faces</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>

<span class="c1"># Initialize the &#39;Color&#39; property of the newly created faces with RGB values.</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Color&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>

<span class="c1"># Make it a &quot;closed&quot; mesh, connecting the four faces to form a surface manifold.</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">connect_opposite_halfedges</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.create_vertices">
<span class="sig-name descname"><span class="pre">create_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><span class="pre">float</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.26)"><span class="pre">numpy.ndarray</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.create_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Adds a set of new vertices to the mesh. <em>coords</em> must be an <span class="math notranslate nohighlight">\(n \times 3\)</span> array specifying the xyz coordinates of the <span class="math notranslate nohighlight">\(n\)</span> vertices to create. The coordinates will be copied into the <code class="docutils literal notranslate"><span class="pre">Position</span></code> vertex property, which is managed by the <a class="reference internal" href="#ovito.data.SurfaceMesh.vertices" title="ovito.data.SurfaceMesh.vertices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vertices</span></code></a> property container. Furthermore, the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.vertex_count" title="ovito.data.SurfaceMeshTopology.vertex_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vertex_count</span></code></a> value of the mesh’s <a class="reference internal" href="#ovito.data.SurfaceMesh.topology" title="ovito.data.SurfaceMesh.topology"><code class="xref py py-attr docutils literal notranslate"><span class="pre">topology</span></code></a> will be incremented by <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Initially, the new vertices will not be associated with any faces. Use <a class="reference internal" href="#ovito.data.SurfaceMesh.create_face" title="ovito.data.SurfaceMesh.create_face"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_face()</span></code></a> or <a class="reference internal" href="#ovito.data.SurfaceMesh.create_faces" title="ovito.data.SurfaceMesh.create_faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_faces()</span></code></a> to create faces connecting the vertices.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.9.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.domain">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">domain</span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.domain" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> describing the (possibly periodic) domain which this surface mesh is embedded in. Note that this cell generally is independent of and may be different from the <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> found in the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.faces">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">faces</span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.faces" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the per-face properties of the mesh.</p>
<p>In general, an arbitrary set of uniquely named properties may be associated with the faces of a surface mesh. OVITO defines the following <em>standard face properties</em>, which have a well-defined meaning and prescribed data layout:</p>
<table class="docutils align-default" id="surface-mesh-face-properties-list">
<thead>
<tr class="row-odd"><th class="head"><p>Standard property name</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Color</span></p></td>
<td><p>float32</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Region</span></p></td>
<td><p>int32</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Selection</span></p></td>
<td><p>int8</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The property <code class="docutils literal notranslate"><span class="pre">Color</span></code> can be set to give each face of the surface mesh an individual color. It overrides the uniform coloring otherwise controlled by the <a class="reference internal" href="ovito_vis.html#ovito.vis.SurfaceMeshVis" title="ovito.vis.SurfaceMeshVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMeshVis</span></code></a> element.</p>
<p>The property <code class="docutils literal notranslate"><span class="pre">Region</span></code> links each face with the volumetric region of the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> that it bounds (see description above). The values of this property are zero-based indices into the <a class="reference internal" href="#ovito.data.SurfaceMesh.regions" title="ovito.data.SurfaceMesh.regions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">regions</span></code></a> list of the mesh.</p>
<p>The property <code class="docutils literal notranslate"><span class="pre">Selection</span></code> controls the selection state of each individual mesh face. This property is set by modifiers that create selections, such as <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ExpressionSelectionModifier" title="ovito.modifiers.ExpressionSelectionModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpressionSelectionModifier</span></code></a>, and is used by modifiers that operate on the subset of currently selected faces, such as <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.AssignColorModifier" title="ovito.modifiers.AssignColorModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AssignColorModifier</span></code></a>. All faces whose <code class="docutils literal notranslate"><span class="pre">Selection</span></code> property has a non-zero value are part of the current selection set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.get_clipping_planes">
<span class="sig-name descname"><span class="pre">get_clipping_planes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.get_clipping_planes" title="Permalink to this definition"></a></dt>
<dd><p>Returns an <span class="math notranslate nohighlight">\(N \times 4\)</span> array containing the definitions of the <em>N</em> clipping planes attached to this <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>.</p>
<p>Each plane is defined by its unit normal vector and a signed displacement magnitude, which determines the plane’s distance from the coordinate origin along the normal, giving four numbers per plane in total. Those parts of the surface mesh which are on the positive side of the plane (in the direction the normal vector) will be cut away during rendering.</p>
<p>Note that the returned Numpy array is a copy of the internal data stored by the <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.get_face_vertices">
<span class="sig-name descname"><span class="pre">get_face_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.26)"><span class="pre">numpy.ndarray</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><span class="pre">list</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.get_face_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Returns an array with the vertex indices of all mesh faces. The parameter <em>flat</em> controls how the face vertices get returned by the function:</p>
<blockquote>
<div><p><strong>flat=False</strong>:   If all <span class="math notranslate nohighlight">\(n\)</span> faces of the mesh have the same, uniform number of vertices, <span class="math notranslate nohighlight">\(m\)</span>, for example, if they are all triangles, then   a 2-d NumPy array of shape <span class="math notranslate nohighlight">\((n, m)\)</span> containing the zero-based vertex indices is returned. Otherwise, a list of lists is returned,   in which nested lists may have different lengths.</p>
<p><strong>flat=True</strong>:   Returns a 1-d array with the vertex lists of all mesh faces stored back to back. A face’s vertex list is preceded by the number of   vertices of that face. Then the actual vertex indices of the face follow. Then the number of vertices of the next face follows, and so on.</p>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.locate_point">
<span class="sig-name descname"><span class="pre">locate_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.locate_point" title="Permalink to this definition"></a></dt>
<dd><p>Determines which spatial region of the mesh contains the given point in 3-d space.</p>
<p>The function returns the numeric ID of the region <em>pos</em> is located in. Note that region ID -1 is typically reserved for the empty exterior region, which, if it exists, is the one <em>not</em> containing any atoms or particles. Whether non-negative indices refer to only filled (interior) regions or also empty regions depends on the algorithm that created the surface mesh and its spatial regions.</p>
<p>The parameter <em>eps</em> is a numerical precision threshold to detect if the query point is positioned exactly on the surface boundary, i.e. on the manifold separating two spatial regions. This condition is indicated by the special return value <code class="docutils literal notranslate"><span class="pre">None</span></code>. Set <em>eps</em> to 0.0 to disable the point-on-boundary test. Then the method will never return <code class="docutils literal notranslate"><span class="pre">None</span></code> as a result, but the determination of the spatial region will become numerically unstable if the query point is positioned right on a boundary surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array-like</em>) – The (x,y,z) coordinates of the query point</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)"><em>float</em></a>) – Numerical precision threshold for point-on-boundary test</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The numeric ID of the spatial region containing <em>pos</em>; or <code class="docutils literal notranslate"><span class="pre">None</span></code> if <em>pos</em> is exactly on the dividing boundary between two regions</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.regions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">regions</span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.regions" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing the properties of the spatial regions of the mesh.</p>
<p>In general, an arbitrary set of uniquely named properties may be associated with the regions of a surface mesh. OVITO defines the following <em>standard region properties</em>, which have a well-defined meaning and prescribed data layout:</p>
<table class="docutils align-default" id="surface-mesh-region-properties-list">
<thead>
<tr class="row-odd"><th class="head"><p>Standard property name</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Color</span></p></td>
<td><p>float32</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Filled</span></p></td>
<td><p>int8</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Selection</span></p></td>
<td><p>int8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Surface Area</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Volume</span></p></td>
<td><p>float64</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The property <code class="docutils literal notranslate"><span class="pre">Color</span></code> can be set to give the faces bounding each of the volumetric regions a different color. It overrides the uniform mesh coloring otherwise controlled by the <a class="reference internal" href="ovito_vis.html#ovito.vis.SurfaceMeshVis" title="ovito.vis.SurfaceMeshVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMeshVis</span></code></a> element.</p>
<p>The property <code class="docutils literal notranslate"><span class="pre">Filled</span></code> is a flag indicating for each region whether it is an interior region, e.g. inside a solid, or an empty exterior region, e.g. outside the solid bounded by the surface. This property is created by the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ConstructSurfaceModifier" title="ovito.modifiers.ConstructSurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConstructSurfaceModifier</span></code></a>. The same is true for the per-region properties <code class="docutils literal notranslate"><span class="pre">Surface</span> <span class="pre">Area</span></code> and <code class="docutils literal notranslate"><span class="pre">Volume</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.set_clipping_planes">
<span class="sig-name descname"><span class="pre">set_clipping_planes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">planes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.SurfaceMesh.set_clipping_planes" title="Permalink to this definition"></a></dt>
<dd><p>Sets the clipping planes of this <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>. The array <em>planes</em> must follow the same format as the one returned by <a class="reference internal" href="#ovito.data.SurfaceMesh.get_clipping_planes" title="ovito.data.SurfaceMesh.get_clipping_planes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_clipping_planes()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.space_filling_region">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">space_filling_region</span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.space_filling_region" title="Permalink to this definition"></a></dt>
<dd><p>Indicates the index of the spatial region that fills the entire domain in case the surface is degenerate, i.e. the mesh has zero faces. The invalid index -1 is typically associated with the empty (exterior) region.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.to_triangle_mesh">
<span class="sig-name descname"><span class="pre">to_triangle_mesh</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><span class="pre">TriangleMesh</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><span class="pre">TriangleMesh</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.26)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.to_triangle_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Converts the surface into a non-periodic <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(<cite>trimesh</cite>, <cite>caps</cite>, <cite>facemap</cite>)</p>
</dd>
</dl>
<ul class="simple">
<li><p><cite>trimesh</cite>: A <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> representing the surface geometry after clipping it at the periodic boundaries of the   <a class="reference internal" href="#ovito.data.SurfaceMesh.domain" title="ovito.data.SurfaceMesh.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a> and any attached clipping planes (see <a class="reference internal" href="#ovito.data.SurfaceMesh.get_clipping_planes" title="ovito.data.SurfaceMesh.get_clipping_planes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_clipping_planes()</span></code></a>).</p></li>
<li><p><cite>caps</cite>: A <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> containing the cap polygons generated at intersections of the periodic surface mesh   with boundaries of the simulation <a class="reference internal" href="#ovito.data.SurfaceMesh.domain" title="ovito.data.SurfaceMesh.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a>. Will be <code class="docutils literal notranslate"><span class="pre">None</span></code> if the surface mesh has no attached <a class="reference internal" href="#ovito.data.SurfaceMesh.domain" title="ovito.data.SurfaceMesh.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a>, the domain   is degenerate, or the surface mesh does not represent a closed manifold.</p></li>
<li><p><cite>facemap</cite>: A NumPy array of indices into the face list of this <code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code>, one for each triangular face of the   <a class="reference internal" href="#ovito.data.TriangleMesh" title="ovito.data.TriangleMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code></a> <cite>trimesh</cite>. This map lets you look up for each face of the output mesh what the corresponding face of the input surface mesh is.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.5.</span></p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.topology">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">topology</span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.topology" title="Permalink to this definition"></a></dt>
<dd><p>A <a class="reference internal" href="#ovito.data.SurfaceMeshTopology" title="ovito.data.SurfaceMeshTopology"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMeshTopology</span></code></a> object storing the face connectivity of the mesh.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMesh.vertices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertices</span></span><a class="headerlink" href="#ovito.data.SurfaceMesh.vertices" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> storing all per-vertex properties of the mesh, including the vertex coordinates.</p>
<p>In general, an arbitrary set of uniquely named properties may be associated with the vertices of a surface mesh. OVITO defines the following <em>standard vertex properties</em>, which have a well-defined meaning and prescribed data layout:</p>
<table class="docutils align-default" id="surface-mesh-vertex-properties-list">
<thead>
<tr class="row-odd"><th class="head"><p>Standard property name</p></th>
<th class="head"><p>Data type</p></th>
<th class="head"><p>Component names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="guilabel">Color</span></p></td>
<td><p>float32</p></td>
<td><p>R, G, B</p></td>
</tr>
<tr class="row-odd"><td><p><span class="guilabel">Position</span></p></td>
<td><p>float64</p></td>
<td><p>X, Y, Z</p></td>
</tr>
<tr class="row-even"><td><p><span class="guilabel">Selection</span></p></td>
<td><p>int8</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The property <code class="docutils literal notranslate"><span class="pre">Position</span></code> is always present and stores the Cartesian vertex coordinates.</p>
<p>The property <code class="docutils literal notranslate"><span class="pre">Color</span></code> can be set to give each vertex of the surface mesh an individual color. It overrides the uniform coloring otherwise controlled by the <a class="reference internal" href="ovito_vis.html#ovito.vis.SurfaceMeshVis" title="ovito.vis.SurfaceMeshVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMeshVis</span></code></a> element. Vertex colors get interpolated across the mesh faces during rendering.</p>
<p>The property <code class="docutils literal notranslate"><span class="pre">Selection</span></code> controls the selection state of each individual mesh vertex. This property is set by modifiers that create selections, such as <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.ExpressionSelectionModifier" title="ovito.modifiers.ExpressionSelectionModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpressionSelectionModifier</span></code></a>, and is used by modifiers that operate on the subset of currently selected vertices, such as <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.AssignColorModifier" title="ovito.modifiers.AssignColorModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AssignColorModifier</span></code></a>. All vertices whose <code class="docutils literal notranslate"><span class="pre">Selection</span></code> property has a non-zero value are part of the current selection set.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">SurfaceMeshTopology</span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.6.</span></p>
</div>
<p>This data structure holds the connectivity information of a <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a>. It is accessible through the <a class="reference internal" href="#ovito.data.SurfaceMesh.topology" title="ovito.data.SurfaceMesh.topology"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.topology</span></code></a> field.
The surface mesh topology consists of <em>vertices</em>, <em>faces</em> and <em>halfedges</em>.</p>
<p>All these topological entities of the mesh are identified by numeric indices ranging from 
0 to (<a class="reference internal" href="#ovito.data.SurfaceMeshTopology.vertex_count" title="ovito.data.SurfaceMeshTopology.vertex_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vertex_count</span></code></a>-1), (<a class="reference internal" href="#ovito.data.SurfaceMeshTopology.face_count" title="ovito.data.SurfaceMeshTopology.face_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">face_count</span></code></a>-1), and (<a class="reference internal" href="#ovito.data.SurfaceMeshTopology.edge_count" title="ovito.data.SurfaceMeshTopology.edge_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">edge_count</span></code></a>-1), respectively. 
The vertices and faces of the mesh may be associated with auxiliary properties, which are stored separately from 
the topology in the <a class="reference internal" href="#ovito.data.SurfaceMesh.vertices" title="ovito.data.SurfaceMesh.vertices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.vertices</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMesh.faces" title="ovito.data.SurfaceMesh.faces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.faces</span></code></a> property containers.
In particular, the spatial coordinates of the mesh vertices are stored as <code class="docutils literal notranslate"><span class="pre">Position</span></code> property array in <a class="reference internal" href="#ovito.data.SurfaceMesh.vertices" title="ovito.data.SurfaceMesh.vertices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.vertices</span></code></a>.</p>
<a class="reference internal image-reference" href="../_images/halfedge_structure.png"><img alt="../_images/halfedge_structure.png" class="align-right" src="../_images/halfedge_structure.png" style="width: 50%;" /></a>
<p>A <em>halfedge</em> is a directed edge <span class="math notranslate nohighlight">\(a \to b\)</span> connecting two vertices <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> – depicted as a half-arrow in the figure. 
A face is implicitly defined by a circular sequence of halfedges that bound the face. Typically, halfedges come in pairs. 
The halfedge <span class="math notranslate nohighlight">\(a \to b\)</span> and its <em>opposite</em> halfedge, <span class="math notranslate nohighlight">\(b \to a\)</span>, form a pair that links two neighboring faces together. 
Thus, halfedge pairs are essential for forming a connected, two-dimensional surface manifold. The surface is said to be <em>closed</em>, 
i.e., it has no open boundaries if all halfedges of the mesh are associated with corresponding opposite halfedges (see <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.is_closed" title="ovito.data.SurfaceMeshTopology.is_closed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_closed</span></code></a>).</p>
<p>For each vertex the topology object maintains a linked-list of directed halfedges leaving that vertex.
It can be accessed through the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_vertex_edge" title="ovito.data.SurfaceMeshTopology.first_vertex_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first_vertex_edge()</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_vertex_edge" title="ovito.data.SurfaceMeshTopology.next_vertex_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_vertex_edge()</span></code></a> methods.</p>
<p>For each face the topology object maintains a circular linked-list of directed halfedges bounding that face (in counter-clockwise winding order).
It can be accessed through the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_face_edge" title="ovito.data.SurfaceMeshTopology.first_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first_face_edge()</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_face_edge" title="ovito.data.SurfaceMeshTopology.next_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_face_edge()</span></code></a>/<a class="reference internal" href="#ovito.data.SurfaceMeshTopology.prev_face_edge" title="ovito.data.SurfaceMeshTopology.prev_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prev_face_edge()</span></code></a> methods.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>All query methods of this class are <em>vectorized</em>, which means they are able to process an array of arguments
in a single function call and will return a corresponding array of results. The advantage of this 
is that the loop over the elements in the argument array runs entirely on the C++ side, which is typically much 
faster than a for-loop in Python. For example, to generate a list with the first halfedge of every mesh face:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Version 1: vectorized function call (fast)</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">first_face_edge</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">face_count</span><span class="p">))</span>

<span class="c1"># Version 2: explicit loop (slow)</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">first_face_edge</span><span class="p">(</span><span class="n">face</span><span class="p">)</span> <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">face_count</span><span class="p">)]</span>
</pre></div>
</div>
</div></blockquote>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.adjacent_face">
<span class="sig-name descname"><span class="pre">adjacent_face</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.adjacent_face" title="Permalink to this definition"></a></dt>
<dd><p>Returns the face that is bounded by the halfedge <em>edge</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.count_face_edges">
<span class="sig-name descname"><span class="pre">count_face_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.count_face_edges" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of halfedges that bound <em>face</em>. See the code example for <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_face_edge" title="ovito.data.SurfaceMeshTopology.next_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_face_edge()</span></code></a> to learn how this method works.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.count_manifolds">
<span class="sig-name descname"><span class="pre">count_manifolds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.count_manifolds" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.count_vertex_edges">
<span class="sig-name descname"><span class="pre">count_vertex_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.count_vertex_edges" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of halfedges that leave <em>vertex</em>. See the code example for <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_vertex_edge" title="ovito.data.SurfaceMeshTopology.next_vertex_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_vertex_edge()</span></code></a> to learn how this method works.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.edge_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">edge_count</span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.edge_count" title="Permalink to this definition"></a></dt>
<dd><p>Total number of halfedges in the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a>. This property is read-only. Halfedges are created automatically by <a class="reference internal" href="#ovito.data.SurfaceMesh.create_face" title="ovito.data.SurfaceMesh.create_face"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMesh.create_face()</span></code></a> or <a class="reference internal" href="#ovito.data.SurfaceMesh.create_faces" title="ovito.data.SurfaceMesh.create_faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMesh.create_faces()</span></code></a> when adding new faces to the mesh topology.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.face_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">face_count</span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.face_count" title="Permalink to this definition"></a></dt>
<dd><p>Number of faces in the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a>. This is always equal to the <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> of the <a class="reference internal" href="#ovito.data.SurfaceMesh.faces" title="ovito.data.SurfaceMesh.faces"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.faces</span></code></a> property container.</p>
<p>This property is read-only. Use <a class="reference internal" href="#ovito.data.SurfaceMesh.create_face" title="ovito.data.SurfaceMesh.create_face"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMesh.create_face()</span></code></a> or <a class="reference internal" href="#ovito.data.SurfaceMesh.create_faces" title="ovito.data.SurfaceMesh.create_faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMesh.create_faces()</span></code></a> to add new faces to the mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.find_edge">
<span class="sig-name descname"><span class="pre">find_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.find_edge" title="Permalink to this definition"></a></dt>
<dd><p>Given a face, finds the halfedge of that face which leads from <em>vertex1</em> to <em>vertex2</em>. If no such halfedge exists, returns -1.</p>
<p>This method can be used to quickly find the edge connecting two vertices of a face without the need to explicitly visit and check each edge bounding the face.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.first_edge_vertex">
<span class="sig-name descname"><span class="pre">first_edge_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.first_edge_vertex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the vertex the given halfedge is leaving from. To retrieve the vertex the halfedge is leading to, call <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.second_edge_vertex" title="ovito.data.SurfaceMeshTopology.second_edge_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">second_edge_vertex()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.first_face_edge">
<span class="sig-name descname"><span class="pre">first_face_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.first_face_edge" title="Permalink to this definition"></a></dt>
<dd><p>Returns some halfedge bounding the given face. Given that first halfedge, all other halfedges bounding the same face can be visited using <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_face_edge" title="ovito.data.SurfaceMeshTopology.next_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_face_edge()</span></code></a> or <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.prev_face_edge" title="ovito.data.SurfaceMeshTopology.prev_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prev_face_edge()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.first_face_vertex">
<span class="sig-name descname"><span class="pre">first_face_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.first_face_vertex" title="Permalink to this definition"></a></dt>
<dd><p>Given a face, this method returns some vertex of that face. This is equivalent to retrieving the vertex to which the first halfedge of the face is connected to, i.e. <code class="docutils literal notranslate"><span class="pre">first_edge_vertex(first_face_edge(face))</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.first_vertex_edge">
<span class="sig-name descname"><span class="pre">first_vertex_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.first_vertex_edge" title="Permalink to this definition"></a></dt>
<dd><p>Returns the head halfedge from the linked list of halfedges leaving <em>vertex</em>. Subsequent halfedges from the linked list can be retrieved with <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_vertex_edge" title="ovito.data.SurfaceMeshTopology.next_vertex_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_vertex_edge()</span></code></a>. If no halfedges are connected to <em>vertex</em>, the method returns -1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.has_opposite_edge">
<span class="sig-name descname"><span class="pre">has_opposite_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><span class="pre">bool</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.has_opposite_edge" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the given halfedge <em>edge</em> is associated with a corresponding reverse halfedge bounding an adjacent face in the same manifold. This is equivalent to checking the return value of <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.opposite_edge" title="ovito.data.SurfaceMeshTopology.opposite_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">opposite_edge()</span></code></a>, which returns -1 to indicate that <em>edge</em> does not have an opposite edge.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.has_opposite_face">
<span class="sig-name descname"><span class="pre">has_opposite_face</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><span class="pre">bool</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.has_opposite_face" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether <em>face</em> is part of a two-sided manifold. A face that is part of a two-sided manifold has a ‘partner’ face with opposite orientation, which can be retrieved through the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.opposite_face" title="ovito.data.SurfaceMeshTopology.opposite_face"><code class="xref py py-meth docutils literal notranslate"><span class="pre">opposite_face()</span></code></a> method.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.is_closed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_closed</span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.is_closed" title="Permalink to this definition"></a></dt>
<dd><p>This is a read-only property indicating whether the surface mesh is fully closed. In a closed mesh, all faces are connected to exactly one adjacent face along each of their halfedges. That means the mesh presents a two-dimensional surface manifold without borders. Furthermore, a closed mesh divides space into an “interior” and an “exterior” region.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ovito.data.SurfaceMesh.connect_opposite_halfedges" title="ovito.data.SurfaceMesh.connect_opposite_halfedges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMesh.connect_opposite_halfedges()</span></code></a>, <a class="reference internal" href="ovito_vis.html#ovito.vis.SurfaceMeshVis.show_cap" title="ovito.vis.SurfaceMeshVis.show_cap"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMeshVis.show_cap</span></code></a></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.7.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.next_face_edge">
<span class="sig-name descname"><span class="pre">next_face_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.next_face_edge" title="Permalink to this definition"></a></dt>
<dd><p>Given the halfedge <em>edge</em> bounding some face, this method returns the following halfedge when going around the face in forward direction (counter-clockwise - when looking at the front side of the face). All halfedges of the face form a circular sequence - without a particular beginning or end. You can loop over this circular sequence in forward or backward direction with the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_face_edge" title="ovito.data.SurfaceMeshTopology.next_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_face_edge()</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.prev_face_edge" title="ovito.data.SurfaceMeshTopology.prev_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prev_face_edge()</span></code></a> methods. Given some mesh face, you can obtain a first halfedge through the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_face_edge" title="ovito.data.SurfaceMeshTopology.first_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first_face_edge()</span></code></a> method.</p>
<p>The following code example shows how to visit all halfedges of a face in order. Since the halfedges form a circular linked list, we have to remember which edge we started from to terminate the loop once we reach the first edge again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_edges</span><span class="p">(</span><span class="n">mesh</span><span class="p">:</span> <span class="n">SurfaceMesh</span><span class="p">,</span> <span class="n">face</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">start_edge</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">first_face_edge</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">next_face_edge</span><span class="p">(</span><span class="n">start_edge</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">edge</span> <span class="o">!=</span> <span class="n">start_edge</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">adjacent_face</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="n">face</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">next_face_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">count</span>

<span class="c1"># The function defined above is equivalent to SurfaceMeshTopology.count_face_edges():</span>
<span class="k">assert</span> <span class="n">count_edges</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">count_face_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.next_manifold_edge">
<span class="sig-name descname"><span class="pre">next_manifold_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.next_manifold_edge" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.next_vertex_edge">
<span class="sig-name descname"><span class="pre">next_vertex_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.next_vertex_edge" title="Permalink to this definition"></a></dt>
<dd><p>Returns another halfedge leaving from the same vertex as <em>edge</em>. Together with <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_vertex_edge" title="ovito.data.SurfaceMeshTopology.first_vertex_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first_vertex_edge()</span></code></a> this method allows you to iterate over all halfedges connected to some vertex. When the end of the vertex’ edge list has been reached, the method returns -1.</p>
<p>The following example demonstrates how to visit all outgoing halfedges of some vertex and count them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_edges</span><span class="p">(</span><span class="n">mesh</span><span class="p">:</span> <span class="n">SurfaceMesh</span><span class="p">,</span> <span class="n">vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">first_vertex_edge</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">edge</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">first_edge_vertex</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="n">vertex</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">next_vertex_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">count</span>

<span class="c1"># The function defined above is equivalent to SurfaceMeshTopology.count_vertex_edges():</span>
<span class="k">assert</span> <span class="n">count_edges</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">count_vertex_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.opposite_edge">
<span class="sig-name descname"><span class="pre">opposite_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.opposite_edge" title="Permalink to this definition"></a></dt>
<dd><p>Given the halfedge <em>edge</em>, returns the reverse halfedge that bounds an adjacent face. This opposite halfedge connects the same two vertices as <em>edge</em> but in reverse order. You can use this method to determine whether the face bounded by <em>edge</em> has a neighboring face that is part of the same manifold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_neighboring_face</span><span class="p">(</span><span class="n">mesh</span><span class="p">:</span> <span class="n">SurfaceMesh</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">opp_edge</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">opposite_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">opp_edge</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">assert</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">first_edge_vertex</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">second_edge_vertex</span><span class="p">(</span><span class="n">opp_edge</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">second_edge_vertex</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">first_edge_vertex</span><span class="p">(</span><span class="n">opp_edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">adjacent_face</span><span class="p">(</span><span class="n">opp_edge</span><span class="p">)</span>
</pre></div>
</div>
<p>You may call the convenience method <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.has_opposite_edge" title="ovito.data.SurfaceMeshTopology.has_opposite_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_opposite_edge()</span></code></a> to determine whether a halfedge is associated with a corresponding opposite halfedge. If the surface mesh does not form a closed manifold, the halfedges at the boundary of the manifold do not have opposite halfedges, because there are no adjacent faces where the surface terminates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.opposite_face">
<span class="sig-name descname"><span class="pre">opposite_face</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.opposite_face" title="Permalink to this definition"></a></dt>
<dd><p>Returns the face on the opposite side of the two-sided manifold, or -1 if the manifold is one-sided. The returned face shares the same vertices with <em>face</em> but in reverse order. Note that <code class="docutils literal notranslate"><span class="pre">opposite_face(opposite_face(face))==face</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.prev_face_edge">
<span class="sig-name descname"><span class="pre">prev_face_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.prev_face_edge" title="Permalink to this definition"></a></dt>
<dd><p>Given the halfedge <em>edge</em> bounding some face, this method returns the previous halfedge going around that face in backward direction (clockwise - when looking at the front side of the face). All halfedges of a face form a circular sequence - without a particular beginning or end. You can loop over this circular sequence in forward or backward direction with the <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.next_face_edge" title="ovito.data.SurfaceMeshTopology.next_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next_face_edge()</span></code></a> and <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.prev_face_edge" title="ovito.data.SurfaceMeshTopology.prev_face_edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prev_face_edge()</span></code></a> methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.second_edge_vertex">
<span class="sig-name descname"><span class="pre">second_edge_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.second_edge_vertex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the vertex the given halfedge is leading to. To retrieve the vertex the halfedge is leaving from, call <a class="reference internal" href="#ovito.data.SurfaceMeshTopology.first_edge_vertex" title="ovito.data.SurfaceMeshTopology.first_edge_vertex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first_edge_vertex()</span></code></a>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.SurfaceMeshTopology.vertex_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertex_count</span></span><a class="headerlink" href="#ovito.data.SurfaceMeshTopology.vertex_count" title="Permalink to this definition"></a></dt>
<dd><p>Number of vertices in the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a>. This is always equal to the <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">count</span></code></a> of the <a class="reference internal" href="#ovito.data.SurfaceMesh.vertices" title="ovito.data.SurfaceMesh.vertices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SurfaceMesh.vertices</span></code></a> property container.</p>
<p>This property is read-only. Use <a class="reference internal" href="#ovito.data.SurfaceMesh.create_vertices" title="ovito.data.SurfaceMesh.create_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SurfaceMesh.create_vertices()</span></code></a> to add new vertices to the mesh.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.TriangleMesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">TriangleMesh</span></span><a class="headerlink" href="#ovito.data.TriangleMesh" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.DataObject" title="ovito.data.DataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.DataObject</span></code></a></p>
<p>This data object type stores a three-dimensional mesh made of vertices and triangular faces. 
Such a mesh can describing general polyhedral geometry to be visualized side by side with the particle simulation data.</p>
<p>Typically, triangle meshes are imported from external geometry data files (e.g. STL, OBJ, VTK formats) using the <a class="reference internal" href="ovito_io.html#ovito.io.import_file" title="ovito.io.import_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_file()</span></code></a> function.
See also the corresponding <a class="reference external" href="../../reference/pipelines/data_objects/triangle_mesh.html#scene-objects-triangle-mesh" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">section of the OVITO user manual</span></a>. 
All triangle meshes in a data collection are accessible through the <a class="reference internal" href="#ovito.data.DataCollection.triangle_meshes" title="ovito.data.DataCollection.triangle_meshes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataCollection.triangle_meshes</span></code></a>
dictionary view.</p>
<p>Note that the <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a> class is a second object type that can represent surface geometries, just like a <code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code>.
In contrast to triangle meshes, surface meshes may be embedded in periodic simulation domains and are closed manifolds in most cases.
Furthermore, surface meshes can store arbitrary per-vertex and per-face property values – something triangle meshes cannot do.
A triangle mesh is a more low-level data structure, which can be sent directly to a GPU for rendering. A surface mesh, in contrast,
is a more high-level data structure, which gets automatically converted to a triangle mesh for visualization.</p>
<p>The visual appearance of the triangle mesh is controlled through the attached <a class="reference internal" href="ovito_vis.html#ovito.vis.TriangleMeshVis" title="ovito.vis.TriangleMeshVis"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMeshVis</span></code></a>
element (see <a class="reference internal" href="#ovito.data.DataObject.vis" title="ovito.data.DataObject.vis"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataObject.vis</span></code></a> field of base class).</p>
<p>A triangle mesh consists of <span class="math notranslate nohighlight">\(n_{\mathrm{v}}\)</span> vertices and <span class="math notranslate nohighlight">\(n_{\mathrm{f}}\)</span> triangular faces. These counts are exposed by the class as attributes
<a class="reference internal" href="#ovito.data.TriangleMesh.vertex_count" title="ovito.data.TriangleMesh.vertex_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vertex_count</span></code></a> and <a class="reference internal" href="#ovito.data.TriangleMesh.face_count" title="ovito.data.TriangleMesh.face_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">face_count</span></code></a>. Each face connects three vertices of the mesh, and several faces may share a vertex. 
The faces are stored as triplets of zero-based indices into the vertex list.</p>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.TriangleMesh.face_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">face_count</span></span><a class="headerlink" href="#ovito.data.TriangleMesh.face_count" title="Permalink to this definition"></a></dt>
<dd><p>The number of triangular faces of the mesh, <span class="math notranslate nohighlight">\(n_{\mathrm{f}}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.TriangleMesh.get_faces">
<span class="sig-name descname"><span class="pre">get_faces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.TriangleMesh.get_faces" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of triangles of the mesh as a NumPy array of shape <span class="math notranslate nohighlight">\((n_{\mathrm{f}}, 3)\)</span>. The array contains for each face three zero-based indices into the mesh’s vertex list as returned by <a class="reference internal" href="#ovito.data.TriangleMesh.get_vertices" title="ovito.data.TriangleMesh.get_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_vertices()</span></code></a>. The returned face array holds a copy of the internal data managed by the <code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.TriangleMesh.get_vertices">
<span class="sig-name descname"><span class="pre">get_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.TriangleMesh.get_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Returns the xyz coordinates of the vertices of the mesh as a NumPy array of shape <span class="math notranslate nohighlight">\((n_{\mathrm{v}}, 3)\)</span>. The returned array holds a copy of the internal vertex data managed by the <code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.TriangleMesh.set_faces">
<span class="sig-name descname"><span class="pre">set_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertex_indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.TriangleMesh.set_faces" title="Permalink to this definition"></a></dt>
<dd><p>Sets the faces of the mesh. <em>vertex_indices</em> must be an array-like object of shape <span class="math notranslate nohighlight">\((n_{\mathrm{f}}, 3)\)</span> containing one integer triplet per triangular face. Each integer is a zero-based index into the mesh’s vertex list. The <code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code> copies the data from the array into its internal storage. If necessary, the value of <a class="reference internal" href="#ovito.data.TriangleMesh.face_count" title="ovito.data.TriangleMesh.face_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">face_count</span></code></a> is automatically adjusted to match the first dimension of the <em>vertex_indices</em> array.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.TriangleMesh.set_vertices">
<span class="sig-name descname"><span class="pre">set_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.TriangleMesh.set_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Sets the xyz coordinates of the vertices of the mesh. <em>coordinates</em> must be an array-like object of shape <span class="math notranslate nohighlight">\((n_{\mathrm{v}}, 3)\)</span>. The <code class="xref py py-class docutils literal notranslate"><span class="pre">TriangleMesh</span></code> copies the data from the array into its internal storage. If necessary, the value of <a class="reference internal" href="#ovito.data.TriangleMesh.vertex_count" title="ovito.data.TriangleMesh.vertex_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">vertex_count</span></code></a> is automatically adjusted to match the first dimension of the <em>coordinates</em> array.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.TriangleMesh.vertex_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertex_count</span></span><a class="headerlink" href="#ovito.data.TriangleMesh.vertex_count" title="Permalink to this definition"></a></dt>
<dd><p>The number of vertices of the mesh, <span class="math notranslate nohighlight">\(n_{\mathrm{v}}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p>0</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ovito.data.VoxelGrid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ovito.data.</span></span><span class="sig-name descname"><span class="pre">VoxelGrid</span></span><a class="headerlink" href="#ovito.data.VoxelGrid" title="Permalink to this definition"></a></dt>
<dd><p>Base: <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ovito.data.PropertyContainer</span></code></a></p>
<figure class="align-right" id="id5" style="width: 20%">
<img alt="../_images/grid_example_2d.png" src="../_images/grid_example_2d.png" />
<figcaption>
<p><span class="caption-text">Cell-data grid</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>A two- or three-dimensional structured grid. Each cell (voxel) of the uniform grid is of the same size and shape.
The overall geometry of the grid, its <a class="reference internal" href="#ovito.data.VoxelGrid.domain" title="ovito.data.VoxelGrid.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a>, is specified by the attached
<a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> object, which describes a three-dimensional parallelepiped or a two-dimensional parallelogram.
See also the corresponding <a class="reference external" href="../../reference/pipelines/data_objects/voxel_grid.html#scene-objects-voxel-grid" title="(in OVITO User Manual v3.10.4)"><span class="xref std std-ref">user manual page</span></a> for more information on this object type.</p>
<p>The <a class="reference internal" href="#ovito.data.VoxelGrid.shape" title="ovito.data.VoxelGrid.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a> property of the grid specifies the number of data points uniformily distributed along each
cell vector of the domain. The size of individual voxels depends on the overall domain size
as well as the number of data points in each spatial direction. See the <a class="reference internal" href="#ovito.data.VoxelGrid.grid_type" title="ovito.data.VoxelGrid.grid_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">grid_type</span></code></a> property, which
controls whether the data values of the uniform grid are associated with the <em>voxel interiors</em> or the <em>vertices</em> (grid line intersections).</p>
<figure class="align-right" id="id6" style="width: 20%">
<img alt="../_images/grid_example_2d_pointdata.png" src="../_images/grid_example_2d_pointdata.png" />
<figcaption>
<p><span class="caption-text">Point-data grid</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Each data point or voxel of the grid may be associated with one or more field values. The data of these <em>voxel properties</em>
is stored in standard <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> array objects, similar to particle or bond properties. Voxel properties can be accessed by name through
the dictionary interface that the <code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code> class inherits from its <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a>
base class.</p>
<p>Voxel grids can be loaded from input data files, e.g. a CHGCAR file containing the electron density computed by the VASP code,
or they can be dynamically generated within OVITO. The <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.SpatialBinningModifier" title="ovito.modifiers.SpatialBinningModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialBinningModifier</span></code></a> lets you
project the information associated with the unstructured particle set to a structured voxel grid.</p>
<p>Given a voxel grid, the <a class="reference internal" href="ovito_modifiers.html#ovito.modifiers.CreateIsosurfaceModifier" title="ovito.modifiers.CreateIsosurfaceModifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateIsosurfaceModifier</span></code></a> can then generate a <a class="reference internal" href="#ovito.data.SurfaceMesh" title="ovito.data.SurfaceMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">SurfaceMesh</span></code></a>
representing an isosurface for a field quantity defined on the voxel grid.</p>
<p><strong>Example</strong></p>
<p>The following code example demonstrates how to create a new <code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code> from scratch
and initialize it with data from a NumPy array:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Starting with an empty DataCollection:</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">DataCollection</span><span class="p">()</span>

<span class="c1"># Create a new SimulationCell object defining the outer spatial dimensions</span>
<span class="c1"># of the grid and the boundary conditions, and add it to the DataCollection:</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_cell</span><span class="p">(</span>
    <span class="n">matrix</span><span class="o">=</span><span class="p">[[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
    <span class="n">pbc</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Generate a three-dimensional Numpy array containing the grid cell values.</span>
<span class="n">nx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="n">nz</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">field_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">))</span>

<span class="c1"># Create the VoxelGrid object and give it a unique identifier by which it can be referred to later on.</span>
<span class="c1"># Link the voxel grid to the SimulationCell object created above, which defines its spatial extensions.</span>
<span class="c1"># Specify the shape of the grid, i.e. the number of cells in each spatial direction.</span>
<span class="c1"># Finally, assign a VoxelGridVis visual element to the data object to make the grid visible in the scene.</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
    <span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;field&quot;</span><span class="p">,</span>
    <span class="n">domain</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span><span class="p">),</span>
    <span class="n">grid_type</span><span class="o">=</span><span class="n">VoxelGrid</span><span class="o">.</span><span class="n">GridType</span><span class="o">.</span><span class="n">CellData</span><span class="p">,</span>
    <span class="n">vis</span><span class="o">=</span><span class="n">VoxelGridVis</span><span class="p">(</span><span class="n">enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transparency</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Add a new property to the voxel grid cells and initialize it with the data from the NumPy array.</span>
<span class="c1"># Note that the data must be provided as linear (1-dim.) array with the following type of memory layout:</span>
<span class="c1"># The first grid dimension (x) is the fasted changing index while the third grid dimension (z) is the</span>
<span class="c1"># slowest varying index. In this example, this corresponds to the &quot;Fortran&quot; memory layout of Numpy.</span>
<span class="n">grid</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Field Value&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">field_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>

<span class="c1"># Instead of the flatten() method above, we could also make use of the method VoxelGrid.view()</span>
<span class="c1"># to obtain a 3-dimensional view of the property array, which supports direct assignment of grid values.</span>
<span class="n">field_prop</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">create_property</span><span class="p">(</span><span class="s1">&#39;Field Value&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">field_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">field_prop</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_data</span>

<span class="c1"># For demonstration purposes, compute an isosurface on the basis of the VoxelGrid created above.</span>
<span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">CreateIsosurfaceModifier</span><span class="p">(</span><span class="n">operate_on</span><span class="o">=</span><span class="s1">&#39;voxels:field&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="o">=</span><span class="s1">&#39;Field Value&#39;</span><span class="p">,</span> <span class="n">isolevel</span><span class="o">=</span><span class="mf">0.7</span><span class="p">))</span>
</pre></div>
</div>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.VoxelGrid.domain">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">domain</span></span><a class="headerlink" href="#ovito.data.VoxelGrid.domain" title="Permalink to this definition"></a></dt>
<dd><p>The <a class="reference internal" href="#ovito.data.SimulationCell" title="ovito.data.SimulationCell"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulationCell</span></code></a> describing the (possibly periodic) domain which this grid is embedded in. Note that this cell generally is independent of and may be different from the <a class="reference internal" href="#ovito.data.DataCollection.cell" title="ovito.data.DataCollection.cell"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cell</span></code></a> found in the <a class="reference internal" href="#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataCollection</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.VoxelGrid.grid_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">grid_type</span></span><a class="headerlink" href="#ovito.data.VoxelGrid.grid_type" title="Permalink to this definition"></a></dt>
<dd><p>This attribute specifies whether the values stored by the grid object are associated with the voxel cell centers or the grid points (vertices). Possible values are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VoxelGrid.GridType.CellData</span></code> (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VoxelGrid.GridType.PointData</span></code></p></li>
</ul>
</div></blockquote>
<p>A <code class="docutils literal notranslate"><span class="pre">CellData</span></code> grid represents a field where the sampling points are located in the centers of the voxel cells. This grid type is typically used for volumetric datasets, which represent some quantity within the discrete voxel cell volumes.</p>
<a class="reference internal image-reference" href="../_images/grid_type_celldata.png"><img alt="../_images/grid_type_celldata.png" src="../_images/grid_type_celldata.png" style="width: 20%;" /></a>
<p>A <code class="docutils literal notranslate"><span class="pre">PointData</span></code> grid represents a field where the sampling points are located at the intersections of the grid lines. Note that, for this grid type only, the type of boundary conditions of the grid’s <a class="reference internal" href="#ovito.data.VoxelGrid.domain" title="ovito.data.VoxelGrid.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a> affect the uniform spacing of the sampling points:</p>
<figure class="align-default" id="id7" style="width: 50%">
<img alt="../_images/grid_type_pointdata.png" src="../_images/grid_type_pointdata.png" />
<figcaption>
<p><span class="caption-text">4 x 4 point-data grid (left: non-periodic domain, right: periodic domain)</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">VoxelGrid.GridType.CellData</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="ovito.data.VoxelGrid.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#ovito.data.VoxelGrid.shape" title="Permalink to this definition"></a></dt>
<dd><p>A 3-tuple specifying the number of sampling points along each of the three cell vectors of the <a class="reference internal" href="#ovito.data.VoxelGrid.domain" title="ovito.data.VoxelGrid.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a>.</p>
<p>For two-dimensional grids, for which the <a class="reference internal" href="#ovito.data.SimulationCell.is2D" title="ovito.data.SimulationCell.is2D"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is2D</span></code></a> property of the <a class="reference internal" href="#ovito.data.VoxelGrid.domain" title="ovito.data.VoxelGrid.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a> is set, the third entry in this <code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code> tuple must be equal to 1.</p>
<p>Assigning a new shape to the grid automatically resizes the one-dimensional data arrays stored by this <a class="reference internal" href="#ovito.data.PropertyContainer" title="ovito.data.PropertyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyContainer</span></code></a> and updates its <a class="reference internal" href="#ovito.data.PropertyContainer.count" title="ovito.data.PropertyContainer.count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PropertyContainer.count</span></code></a> property match the product of the three dimensions, i.e. the total number of data points.</p>
<dl class="field-list simple">
<dt class="field-odd">Default<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ovito.data.VoxelGrid.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ovito.data.VoxelGrid.view" title="Permalink to this definition"></a></dt>
<dd><p>Returns a shaped view of the given grid property, which reflects the 2- or 3-dimensional <a class="reference internal" href="#ovito.data.VoxelGrid.shape" title="ovito.data.VoxelGrid.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a> of the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>|</em><a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><em>Property</em></a>) – The name of the grid property to look up. May include the underscore suffix to make the property mutable. Alternatively, you can directly specify a <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> object from this <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <a class="reference external" href="https://numpy.org/doc/stable/user/basics.copies.html">NumPy view</a> of the underlying property array.</p>
</dd>
</dl>
<p>Because the <a class="reference internal" href="#ovito.data.VoxelGrid" title="ovito.data.VoxelGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">VoxelGrid</span></code></a> class internally uses linear <a class="reference internal" href="#ovito.data.Property" title="ovito.data.Property"><code class="xref py py-class docutils literal notranslate"><span class="pre">Property</span></code></a> arrays to store the voxel cell values,
you normally would have to convert back and forth between the linear index space of the underlying property storage and
the 2- or 3-dimensional grid space to access individual voxel cells.</p>
<p>The <a class="reference internal" href="#ovito.data.VoxelGrid.view" title="ovito.data.VoxelGrid.view"><code class="xref py py-meth docutils literal notranslate"><span class="pre">view()</span></code></a> helper method frees you from having to map grid coordinates to array indices because it gives you a shaped NumPy view
of the underlying linear storage, which reflects the correct multi-dimensional shape of the grid. For 3-dimensional grids, the ordering of the
view’s dimensions is <span class="math notranslate nohighlight">\(x,y,z[,k]\)</span>, with <span class="math notranslate nohighlight">\(k\)</span> being an extra dimension that is only present if the accessed property
is a vector field quantity. For 2-dimensional grids, the ordering of the view’s dimensions is <span class="math notranslate nohighlight">\(x,y[,k]\)</span>.</p>
<p>The returned view lets you conveniently access the values of individual grid cells based on multi-dimensional grid coordinates.
Here, as an example, the scalar field property <code class="docutils literal notranslate"><span class="pre">c_ave</span></code> of a 3-dimensional voxel grid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span>
<span class="n">field</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;c_ave&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.9.0.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ovito.html" class="btn btn-neutral float-left" title="ovito" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ovito_io.html" class="btn btn-neutral float-right" title="ovito.io" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024 OVITO GmbH, Germany.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>